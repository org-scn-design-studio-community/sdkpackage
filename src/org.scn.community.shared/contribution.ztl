/* GENERATED - DO NOT EDIT */
/**
 * Copyright 2015, Contributors
 * 
 * Original Source Code Location:
 *  https://github.com/org-scn-design-studio-community/sdkpackage/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */


/**
 * enum filed definition
 */
class org_scn_community_shared_AlignEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_Align extends Enum {

	/** Start */
	org_scn_community_shared_AlignEnumfield Start;
       
	/** End */
	org_scn_community_shared_AlignEnumfield End;

	/** None */
	org_scn_community_shared_AlignEnumfield None;

	/** Both */
	org_scn_community_shared_AlignEnumfield both;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_BarColorEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_BarColor extends Enum {

	/** Critical */
	org_scn_community_shared_BarColorEnumfield Critical;
       
	/** Negative */
	org_scn_community_shared_BarColorEnumfield Negative;

	/** Neutral */
	org_scn_community_shared_BarColorEnumfield Neutral;

	/** Positive */
	org_scn_community_shared_BarColorEnumfield Positive;
}

/**
	Array Holder for Component, Name and Type
 */
class org.scn.community.shared.ComponentHolder {
	  Component component;
	  String name;
	  String type;
}

/**
	Array for Components
	<br>
	var panels = COMPONENTHOLDER.getPanels();<br>
	<br>
	// a loop for all entries<br>
	// content is of type Component<br>
	panels.forEach(function(element, index) {<br>
	
		// panel is of type Component<br>
		var componentWidth = element.getWidth();<br>
	});
 */
class org.scn.community.shared.ComponentArray extends Array {
	org.scn.community.shared.ComponentArray (org.scn.community.shared.ComponentHolder h);
}


/**
	Array Holder for DataSourceAlias, Name and Type
 */
class org.scn.community.shared.DataSourceHolder {
	  DataSourceAlias datasource;
	  String name;
	  String type;
}

/**
	Array for DataSourceAlias
	<br>
	var panels = COMPONENTHOLDER.getPanels();<br>
	<br>
	// a loop for all entries<br>
	// content is of type DataSourceAlias<br>
	panels.forEach(function(element, index) {<br>
	
		// panel is of type DataSourceAlias<br>
		var componentWidth = element.getWidth();<br>
	});
 */
class org.scn.community.shared.DataSourceArray extends Array {
	org.scn.community.shared.DataSourceArray (org.scn.community.shared.DataSourceHolder h);
}

/**
 * enum filed definition
 */
class org_scn_community_shared_BrowserEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_Browser extends Enum {

	/** DEFAULT */
	org_scn_community_shared_BrowserEnumfield CHROME;
       
	/** EMPH */
	org_scn_community_shared_BrowserEnumfield SAFARI;

	/** ACCEPT */
	org_scn_community_shared_BrowserEnumfield MOZILLA;

	/** REJECT */
	org_scn_community_shared_BrowserEnumfield IE;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ButtonStyleEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_ButtonStyle extends Enum {

	/** DEFAULT */
	org_scn_community_shared_ButtonStyleEnumfield Default;
       
	/** EMPH */
	org_scn_community_shared_ButtonStyleEnumfield Emph;

	/** ACCEPT */
	org_scn_community_shared_ButtonStyleEnumfield Accept;

	/** REJECT */
	org_scn_community_shared_ButtonStyleEnumfield Reject;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ButtonTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_ButtonType extends Enum {

	/** Default */
	org_scn_community_shared_ButtonTypeEnumfield Default;
       
	/** Transparent */
	org_scn_community_shared_ButtonTypeEnumfield Transparent;

	/** Accept */
	org_scn_community_shared_ButtonTypeEnumfield Accept;

	/** Reject */
	org_scn_community_shared_ButtonTypeEnumfield Reject;
	
	/** Back */
	org_scn_community_shared_ButtonTypeEnumfield Back;
	
	/** Emphasized */
	org_scn_community_shared_ButtonTypeEnumfield Emphasized;
	
	/** Up */
	org_scn_community_shared_ButtonTypeEnumfield Up;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_ChartColorPaleteEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify
 */
class org_scn_community_shared_ChartColorPalete extends Enum {
       
	/** Mono */
	org_scn_community_shared_ChartColorPaleteEnumfield Mono;	
    
	/** Monochromatic */
	org_scn_community_shared_ChartColorPaleteEnumfield Monochromatic;	
    
	/** Contrast */
	org_scn_community_shared_ChartColorPaleteEnumfield Contrast;	
    
	/** Triade */
	org_scn_community_shared_ChartColorPaleteEnumfield Triade;	
    
	/** Tetrade */
	org_scn_community_shared_ChartColorPaleteEnumfield Tetrade;	
    
	/** Analogic */
	org_scn_community_shared_ChartColorPaleteEnumfield Analogic;	
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ChartSimpleTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify
 */
class org_scn_community_shared_ChartSimpleType extends Enum {

	/** Line */
	org_scn_community_shared_ChartSimpleTypeEnumfield Line;
       
	/** Bar */
	org_scn_community_shared_ChartSimpleTypeEnumfield Bar;	
    
	/** LineBar */
	org_scn_community_shared_ChartSimpleTypeEnumfield LineBar;	
    
	/** Radar */
	org_scn_community_shared_ChartSimpleTypeEnumfield Radar;	
    
	/** PolarArea */
	org_scn_community_shared_ChartSimpleTypeEnumfield PolarArea;	
    
	/** Pie */
	org_scn_community_shared_ChartSimpleTypeEnumfield Pie;	
    
	/** Doughnut */
	org_scn_community_shared_ChartSimpleTypeEnumfield Doughnut;	
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ContentNotationEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ContentNotation extends Enum {

	/** PARENT_CHILD_TEXT_URL, for components which are supporting this notation */
	org_scn_community_shared_ContentNotationEnumfield PARENT_CHILD_TEXT_URL;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_DateViewTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_DateViewType extends Enum {

	/** Day */
	org_scn_community_shared_DateViewTypeEnumfield Day;
       
	/** Week */
	org_scn_community_shared_DateViewTypeEnumfield Week;

	/** Month */
	org_scn_community_shared_DateViewTypeEnumfield Month;

	/** Year */
	org_scn_community_shared_DateViewTypeEnumfield Year;

	/** Custom_Week */
	org_scn_community_shared_DateViewTypeEnumfield Custom_Week;

	/** Custom_Duration */
	org_scn_community_shared_DateViewTypeEnumfield Custom_Duration;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_DimensionSetEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_DimensionSet extends Enum {

	/** ALL_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield All;
       
	/** RESULT_SET_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield Resultset;

	/** CUSTOM_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield Custom;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_DecimalPlacesEnumfield extends Enumfield {
       
}

/**
 * a set of constants definition 
 */
class org_scn_community_shared_DecimalPlaces extends Enum {

	/** 0 */
	org_scn_community_shared_DecimalPlacesEnumfield D0;
       
	/** 1 */
	org_scn_community_shared_DecimalPlacesEnumfield D1;

	/** 2 */
	org_scn_community_shared_DecimalPlacesEnumfield D2;

	/** 3 */
	org_scn_community_shared_DecimalPlacesEnumfield D3;

	/** 4 */
	org_scn_community_shared_DecimalPlacesEnumfield D4;

	/** 5 */
	org_scn_community_shared_DecimalPlacesEnumfield D5;

	/** 6 */
	org_scn_community_shared_DecimalPlacesEnumfield D6;

	/** 7 */
	org_scn_community_shared_DecimalPlacesEnumfield D7;

	/** 8 */
	org_scn_community_shared_DecimalPlacesEnumfield D8;

	/** 9 */
	org_scn_community_shared_DecimalPlacesEnumfield D9;

	/** 10 */
	org_scn_community_shared_DecimalPlacesEnumfield D10;

	/** 11 */
	org_scn_community_shared_DecimalPlacesEnumfield D11;

	/** 12 */
	org_scn_community_shared_DecimalPlacesEnumfield D12;

	/** 13 */
	org_scn_community_shared_DecimalPlacesEnumfield D13;

	/** 14 */
	org_scn_community_shared_DecimalPlacesEnumfield D14;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_FormatStyleEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_FormatStyle extends Enum {

	/** Short */
	org_scn_community_shared_FormatStyleEnumfield Short;
       
	/** Medium */
	org_scn_community_shared_FormatStyleEnumfield Medium;

	/** Long */
	org_scn_community_shared_FormatStyleEnumfield Long;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_FormattingOperatorEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_FormattingOperator extends Enum {

	/** Use_First */
	org_scn_community_shared_FormattingOperatorEnumfield Use_First;
       
	/** Use_Last */
	org_scn_community_shared_FormattingOperatorEnumfield Use_Last;

	/** Collect */
	org_scn_community_shared_FormattingOperatorEnumfield Collect;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_HorizontalAlignEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_HorizontalAlign extends Enum {

	/** Left */
	org_scn_community_shared_HorizontalAlignEnumfield Left;
       
	/** Right */
	org_scn_community_shared_HorizontalAlignEnumfield Right;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ImageSizeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ImageSize extends Enum {

	/** 16x16 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_16px;

	/** 32x32 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_32px;

	/** 64x64 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_64px;
	
	/** 128x128 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_128px;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_MemberDisplayEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_MemberDisplay extends Enum {

	/** Text */
	org_scn_community_shared_MemberDisplayEnumfield Text;
       
	/** Text Value */
	org_scn_community_shared_MemberDisplayEnumfield Text_Value;

	/** Text Key*/
	org_scn_community_shared_MemberDisplayEnumfield Text_Key;

	/** Text Count*/
	org_scn_community_shared_MemberDisplayEnumfield Text_Count;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_MemberSelectionEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify member selection 
 */
class org_scn_community_shared_MemberSelection extends Enum {

	/** Top */
	org_scn_community_shared_MemberSelectionEnumfield Top;
	
	/** Bottom */
	org_scn_community_shared_MemberSelectionEnumfield Bottom;
		
	/** Both */
	org_scn_community_shared_MemberSelectionEnumfield Both;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_NavigationTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_NavigationType extends Enum {

	/** PAGINATOR */
	org_scn_community_shared_NavigationTypeEnumfield Paginator;
       
	/** SCROLLBAR */
	org_scn_community_shared_NavigationTypeEnumfield Scrollbar;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_OrientationEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify
 */
class org_scn_community_shared_Orientation extends Enum {

	/** Horizontal */
	org_scn_community_shared_OrientationEnumfield Horizontal;
       
	/** Vertical */
	org_scn_community_shared_OrientationEnumfield Vertical;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_OrientationTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_OrientationType extends Enum {

	/** Horizontal Top */
	org_scn_community_shared_OrientationTypeEnumfield HorizontalTop;
       
	/** Horizontal Bottom */
	org_scn_community_shared_OrientationTypeEnumfield HorizontalBottom;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_PlacementTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_PlacementType extends Enum {

	/** Auto */
	org_scn_community_shared_PlacementTypeEnumfield Auto;
       
	/** Horizontal */
	org_scn_community_shared_PlacementTypeEnumfield Horizontal;

	/** Vertical */
	org_scn_community_shared_PlacementTypeEnumfield Vertical;

	/** Left */
	org_scn_community_shared_PlacementTypeEnumfield Left;
	
	/** Right */
	org_scn_community_shared_PlacementTypeEnumfield Right;
	
	/** Top */
	org_scn_community_shared_PlacementTypeEnumfield Top;
	
	/** Bottom */
	org_scn_community_shared_PlacementTypeEnumfield Bottom;
	
	/** After */
	org_scn_community_shared_PlacementTypeEnumfield After;
	
	/** Before */
	org_scn_community_shared_PlacementTypeEnumfield Before;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionStateEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_SelectionState extends Enum {

	/** Checked */
	org_scn_community_shared_SelectionStateEnumfield Checked;
       
	/** Unchecked */
	org_scn_community_shared_SelectionStateEnumfield Unchecked;

	/** Mixed */
	org_scn_community_shared_SelectionStateEnumfield Mixed;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SelectionType extends Enum {

	/** Single */
	org_scn_community_shared_SelectionTypeEnumfield Single;
       
	/** Range */
	org_scn_community_shared_SelectionTypeEnumfield Range;

	/** Multiple */
	org_scn_community_shared_SelectionTypeEnumfield Multiple;
	
	/** Single Toggle */
	org_scn_community_shared_SelectionTypeEnumfield SingleToggle;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SecondValueContentEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_SecondValueContent extends Enum {

	/** Value */
	org_scn_community_shared_SecondValueContentEnumfield Value;
       
	/** Key */
	org_scn_community_shared_SecondValueContentEnumfield Key;

	/** Count */
	org_scn_community_shared_SecondValueContentEnumfield Count;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SortDirectionEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_SortDirection extends Enum {

	/** ASCENDING */
	org_scn_community_shared_SortDirectionEnumfield Ascending;
       
	/** DESCENDING */
	org_scn_community_shared_SortDirectionEnumfield Descending;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SelectionType extends Enum {

	/** Single */
	org_scn_community_shared_SelectionTypeEnumfield Single;
       
	/** Range */
	org_scn_community_shared_SelectionTypeEnumfield Range;

	/** Multiple */
	org_scn_community_shared_SelectionTypeEnumfield Multiple;
	
	/** Single Toggle */
	org_scn_community_shared_SelectionTypeEnumfield SingleToggle;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SortTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SortType extends Enum {

	/** Default */
	org_scn_community_shared_SortTypeEnumfield Default;
       
	/** Alphabetical */
	org_scn_community_shared_SortTypeEnumfield Alphabetical;

	/** Count */
	org_scn_community_shared_SortTypeEnumfield Count;
	
	/** Selected */
	org_scn_community_shared_SortTypeEnumfield Selected;

	/** Value */
	org_scn_community_shared_SortTypeEnumfield Value;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_WrappingEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify
 */
class org_scn_community_shared_Wrapping extends Enum {

	/** None */
	org_scn_community_shared_WrappingEnumfield None;
       
	/** Off */
	org_scn_community_shared_WrappingEnumfield Off;

	/** Soft */
	org_scn_community_shared_WrappingEnumfield Soft;

	/** Hard */
	org_scn_community_shared_WrappingEnumfield Hard;
}

/**
	Holder for Dimension, Member. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.DimensionMemberArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.DimensionMember<br>
		var elDimension = element.dimension;<br>
		var elMember = element.member;<br>
	});
 */
class org.scn.community.shared.DimensionMember {
  String dimension;
  String member;
}

/**
	Array for org.scn.community.shared.DimensionMember. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.DimensionMemberArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.DimensionMemberValue<br>
		var elDimension = element.dimension;<br>
		var elMember = element.member;<br>
	});
 */
class org.scn.community.shared.DimensionMemberArray extends Array {
	org.scn.community.shared.DimensionMemberArray (org.scn.community.shared.DimensionMember b);
}


class org.scn.community.shared.HierarchyMember {
	int 		ID;
	String 		key;
	String 		text;
	int 		level;
	String 		type;
	int 		parentID;
	String 		parentKey;
	boolean 	isLeaf;
	String 		nodeState;
}

class org.scn.community.shared.HierarchyMemberArray extends Array {
	org.scn.community.shared.HierarchyMemberArray (org.scn.community.shared.HierarchyMember b);
}
/**
	Holder for Key, Text. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.Key<br>
		var elKey = element.key;<br>
	});
 */
class org.scn.community.shared.Key {
  String key;
}

/**
	Array for org.scn.community.shared.KeyText. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyValue<br>
		var elKey = element.key;<br>
	});
 */
class org.scn.community.shared.KeyArray extends Array {
	org.scn.community.shared.KeyArray (org.scn.community.shared.Key b);
}

/**
	Holder for Key, Label. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabel<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	});
 */
class org.scn.community.shared.KeyLabel {
  String key;
  String label;
}

/**
	Array for org.scn.community.shared.KeyLabel. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	});
 */
class org.scn.community.shared.KeyLabelArray extends Array {
	org.scn.community.shared.KeyLabelArray (org.scn.community.shared.KeyLabel b);
}

/**
	Holder for Key, Text. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyText<br>
		var elKey = element.key;<br>
		var elText = element.text;<br>
	});
 */
class org.scn.community.shared.KeyText {
  String key;
  String text;
}

/**
	Array for org.scn.community.shared.KeyText. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyTextValue<br>
		var elKey = element.key;<br>
		var elText = element.text;<br>
	});
 */
class org.scn.community.shared.KeyTextArray extends Array {
	org.scn.community.shared.KeyTextArray (org.scn.community.shared.KeyText b);
}

/**
	Holder for Key, Label, Value. You can access the content as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	});
 */
class org.scn.community.shared.KeyLabelValue {
  String key;
  String label;
  float value;
}

/**
	Array for org.scn.community.shared.KeyLabelValue. You can use this array as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	});
 */
class org.scn.community.shared.KeyLabelValueArray extends Array {
	org.scn.community.shared.KeyLabelValueArray (org.scn.community.shared.KeyLabelValue b);
}

/**
	Holder for Key, Label, Value + param1, param2, param3. You can access the content as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueProperty();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValuePropertyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValueProperty<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	 	<br>
	 	var param1 = element.property1;<br>
	 	var param2 = element.property2;<br>
	 	var param3 = element.property3;<br>
	});
 */
class org.scn.community.shared.KeyLabelValueProperty {
	String key;
	String label;
	float value;
	String prop1;
	String prop2;
	String prop3;
}

/**
Array for org.scn.community.shared.KeyLabelValueProperty. You can use this array as in below example.
<br>
var content = COLLECTION_1.getAsKeyLabelValuePropertyArray();<br>
<br>
// a loop for all entries<br>
// content is of type org.scn.community.shared.KeyLabelValuePropertyArray<br>
content.forEach(function(element, index) {<br>

	// element is of type org.scn.community.shared.KeyLabelValueProperty<br>
	var elKey = element.key;<br>
	var elLabel = element.label;<br>
 	var elValue = "( " + element.value + " )");<br>
 	<br>
 	var param1 = element.prop1;<br>
 	var param2 = element.prop2;<br>
 	var param3 = element.prop3;<br>
 });
*/
class org.scn.community.shared.KeyLabelValuePropertyArray extends Array {
	org.scn.community.shared.KeyLabelValuePropertyArray (org.scn.community.shared.KeyLabelValueProperty b);
}

/**
	Holder for Name, Value. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.NameValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.NameValue<br>
		var elName = element.name;<br>
		var elValue = element.value;<br>
	});
 */
class org.scn.community.shared.NameValue {
  String name;
  String value;
}

/**
	Array for org.scn.community.shared.NameValue. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.NameValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.NameValueValue<br>
		var elName = element.name;<br>
		var elValue = element.value;<br>
	});
 */
class org.scn.community.shared.NameValueArray extends Array {
	org.scn.community.shared.NameValueArray (org.scn.community.shared.NameValue b);
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ValidationStateEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ValidationState extends Enum {

	/** None */
	org_scn_community_shared_ValidationStateEnumfield None;
       
	/** Error */
	org_scn_community_shared_ValidationStateEnumfield Error;

	/** Success */
	org_scn_community_shared_ValidationStateEnumfield Success;
	
	/** Warning */
	org_scn_community_shared_ValidationStateEnumfield Warning;
}

/**
	Holder for value. You can use the content as in below example.
	<br>
	var content = COLLECTION_1.getAsValueTextArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.ValueTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.ValueText<br>
		var elValue = element.value;<br>
		var elText = element.text;<br>
	});
*/
class org.scn.community.shared.ValueText {
  String value;
  String text;
}

/**
	Array for org.scn.community.shared.ValueText. You can use this array as in below example.
	<br>
	var content = ARRAY_1.getAsValueTextArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.ValueTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.ValueText<br>
		var elValue = element.value;<br>
		var elText = element.text;<br>
	});
*/
class org.scn.community.shared.ValueTextArray extends Array {
	org.scn.community.shared.ValueTextArray (org.scn.community.shared.ValueText b);
}
/** GENERATED BY SAPUI5 SIMPLE VALUES DEFINITIONS */

/**
 * Enumeration of possible BulletChart display modes.
 */
class org_scn_community_shared_BulletChartModeEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible BulletChart display modes. 
 */
class org_scn_community_shared_BulletChartMode extends Enum {

	/** Displays the Actual value. */
	org_scn_community_shared_BulletChartModeEnumfield Actual;

	/** Displays delta between the Actual and Threshold values. */
	org_scn_community_shared_BulletChartModeEnumfield Delta;


}


/**
 * Enumeration of possible theme specific background colors.
 */
class org_scn_community_shared_CommonBackgroundEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible theme specific background colors. 
 */
class org_scn_community_shared_CommonBackground extends Enum {

	/** The lightest background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Lightest;

	/** Extra light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield ExtraLight;

	/** Light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Light;

	/** Medium light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield MediumLight;

	/** Medium background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Medium;

	/** Dark background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Dark;

	/** Extra dark background color. */
	org_scn_community_shared_CommonBackgroundEnumfield ExtraDark;

	/** The darkest background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Darkest;


}


/**
 * Enumeration of possible PointTile size settings.
 */
class org_scn_community_shared_InfoTileSizeEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible PointTile size settings. 
 */
class org_scn_community_shared_InfoTileSize extends Enum {

	/** Extra small size. */
	org_scn_community_shared_InfoTileSizeEnumfield XS;

	/** Small size. */
	org_scn_community_shared_InfoTileSizeEnumfield S;

	/** Medium size. */
	org_scn_community_shared_InfoTileSizeEnumfield M;

	/** Large size. */
	org_scn_community_shared_InfoTileSizeEnumfield L;

	/** The size of the tile depends on the device it is running on. It is large on desktop, medium on tablet and small on phone. */
	org_scn_community_shared_InfoTileSizeEnumfield Auto;


}


/**
 * Enumeration of possible InfoTile value color settings.
 */
class org_scn_community_shared_InfoTileValueColorEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible InfoTile value color settings. 
 */
class org_scn_community_shared_InfoTileValueColor extends Enum {

	/** Neutral InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Neutral;

	/** Good InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Good;

	/** Critical InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Critical;

	/** Error InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Error;


}


/**
 * The list of possible MicroAreaChart views.
 */
class org_scn_community_shared_MicroAreaChartViewEnumfield extends Enumfield {
       
}

/**
 * The list of possible MicroAreaChart views. 
 */
class org_scn_community_shared_MicroAreaChartView extends Enum {

	/** The view with labels on the top and bottom. */
	org_scn_community_shared_MicroAreaChartViewEnumfield Normal;

	/** The view with labels on the left and right. */
	org_scn_community_shared_MicroAreaChartViewEnumfield Wide;


}


/**
 * Describes the state info connected to the content displayed in the Process Flow Node body. Also Process Flow Lane Header uses this enumeration for the chart
 */
class org_scn_community_shared_ProcessFlowNodeStateEnumfield extends Enumfield {
       
}

/**
 * Describes the state info connected to the content displayed in the Process Flow Node body. Also Process Flow Lane Header uses this enumeration for the chart 
 */
class org_scn_community_shared_ProcessFlowNodeState extends Enum {

	/** Positive status for a Created document: document is done, finished, solved  */
	org_scn_community_shared_ProcessFlowNodeStateEnumfield Positive;

	/** Negative status for a Created document: a document has an issue */
	org_scn_community_shared_ProcessFlowNodeStateEnumfield Negative;

	/** Planned status for a document: a document is planned */
	org_scn_community_shared_ProcessFlowNodeStateEnumfield Planned;

	/** Neutral status for a Created document: document is in progress  */
	org_scn_community_shared_ProcessFlowNodeStateEnumfield Neutral;

	/** Planned document has an issue */
	org_scn_community_shared_ProcessFlowNodeStateEnumfield PlannedNegative;


}


/**
 * The zoom level defines level of details for the node and how much space the process flow requires.
 */
class org_scn_community_shared_ProcessFlowZoomLevelEnumfield extends Enumfield {
       
}

/**
 * The zoom level defines level of details for the node and how much space the process flow requires. 
 */
class org_scn_community_shared_ProcessFlowZoomLevel extends Enum {

	/** zoom level for least details - only icon is displayed */
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield One;

	/** The detail is icon, title text and no additional texts */
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield Two;

	/** The full detail view of the node but with smaller font size */
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield Three;

	/** The full details with normal font size */
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield Four;


}


/**
 * Configuration options for text alignments.
 */
class org_scn_community_shared_TextAlignEnumfield extends Enumfield {
       
}

/**
 * Configuration options for text alignments. 
 */
class org_scn_community_shared_TextAlign extends Enum {

	/** Locale-specific positioning at the beginning of the line. */
	org_scn_community_shared_TextAlignEnumfield Begin;

	/** Locale-specific positioning at the end of the line. */
	org_scn_community_shared_TextAlignEnumfield End;

	/** Hard option for left alignment. */
	org_scn_community_shared_TextAlignEnumfield Left;

	/** Hard option for right alignment. */
	org_scn_community_shared_TextAlignEnumfield Right;

	/** Centered text alignment. */
	org_scn_community_shared_TextAlignEnumfield Center;

	/** Sets no text align, so the browser default is used. */
	org_scn_community_shared_TextAlignEnumfield Initial;


}


/**
 * Configuration options for the direction of texts.
 */
class org_scn_community_shared_TextDirectionEnumfield extends Enumfield {
       
}

/**
 * Configuration options for the direction of texts. 
 */
class org_scn_community_shared_TextDirection extends Enum {

	/** Specifies left-to-right text direction. */
	org_scn_community_shared_TextDirectionEnumfield LTR;

	/** Specifies right-to-left text direction. */
	org_scn_community_shared_TextDirectionEnumfield RTL;

	/** Inherits the direction from its parent control/container. */
	org_scn_community_shared_TextDirectionEnumfield Inherit;


}


/**
 * Marker for the correctness of the current value.
 */
class org_scn_community_shared_ValueStateEnumfield extends Enumfield {
       
}

/**
 * Marker for the correctness of the current value. 
 */
class org_scn_community_shared_ValueState extends Enum {

	/** State is not valid. */
	org_scn_community_shared_ValueStateEnumfield Error;

	/** State is valid but with a warning. */
	org_scn_community_shared_ValueStateEnumfield Warning;

	/** State is valid. */
	org_scn_community_shared_ValueStateEnumfield Success;

	/** State is not specified. */
	org_scn_community_shared_ValueStateEnumfield None;


}
/**
 * Class for reusable ZTL component methods
 */
class org.scn.community.shared.Component extends Component {
	
	@Visibility(private)
	void internalWriteLog(String log) {*
		// only for debugging
		var active = false;
	
		if(active) {
			APPLICATION.log(log);
		}
	*}

	/**
	 * DO NOT USE, ONLY FOR DEBUG ACTIVATION
	 */
	@Visibility(private)
	boolean isDebug(optional String componentName) {*
		// quick check here
		if(componentName == undefined) {
			if(this._dbgDEBUG == "+") { return true; }
			if(this._dbgDEBUG == "-") { return false; }
			componentName = "DEBUG";
		} else {
			if(this["_dbg" + componentName] == "+") { return true; }
			if(this["_dbg" + componentName] == "-") { return false; }
		}
	
		internal_assureGlobalAccess ();
		
		var something = this.getGlobal()[componentName];
		if(something != undefined) {
			this["_dbg" + componentName] == "+";
			return true;
		} else {
			this["_dbg" + componentName] == "-";
			return false;
		}
	*}
	
	/**
	 * Internal function to read return global scope
	 * http://stackoverflow.com/questions/1162998/how-can-i-add-an-object-property-to-the-global-object-in-rhino-javascript
	 */
	@Visibility(private)
	void internal_assureGlobalAccess () {*
		if(this.getGlobal == undefined) {
			this.getGlobal = function () {
				return (function() {
					return this;
				}).call(null);
			}
		}
	*}
	
	/**
	 * Converts Choice values to Strings
	 */
	@Visibility(private)
	String convertChoiceToString (String choice) {*
		return choice;
	*}

	/**
	 * Converts String values to Choices
	 */
	@Visibility(private)
	String convertToStringChoice (String value) {*
		value = value.toUpper();
		value = value.replace(" ", "_");
		return value;
	*}
}

/**
 * Class for reusable ZTL data bound component methods
 */
class org.scn.community.shared.DataComponent extends DataBoundComponent {

	@Visibility(private)
	String superReadMembers(
			/**technical name of the dimension*/String dimensionName,
			/**max members to load (optional, default 1000)*/optional int maxMembers
			) {*
		var ds = this.getDataSource();
		
		var membersArray = [];
	
		if(maxMembers == undefined) {
			maxMembers = 1000;
		}
		
		var members = ds.getMembers(dimensionName, maxMembers);

		this.internalWriteLog("Load Members [length]: " + members.length);
		
		members.forEach(function(member, index) {
			var memberEntry = {};
			membersArray.push(memberEntry);
			
			memberEntry.key = member.internalKey;
			// member.internalNoncompoundedKey;
			memberEntry.keyExt = member.externalKey;
			// member.externalNoncompoundedKey;
			memberEntry.text = member.text;
		});
		
		var membersMetaData = {};
		membersMetaData.dimensionName = dimensionName;
		membersMetaData.members = membersArray;
		
		var result = JSON.stringify(membersMetaData);
		return result;
	
	*}
	
	@Visibility(private)
	String superReadMetaData() {*
		// APPLICATION.createInfoMessage("_readMetaData");
		
		var ds = this.getDataSource();
	  
		var dimensionsArray = [];
	
		var dims = ds.getDimensions();
		dims.forEach(function(element, index) {
			var dimEntry = {};
			dimensionsArray.push(dimEntry);
			dimEntry.name = element.name;
			dimEntry.text = element.text;
			
			if (element.isMeasuresDimension) {
				var measuresArray = [];
				var measures = ds.getMembers(element.name, 100);
				measures.forEach(function(measure) {
					var measureEntry = {};
					measuresArray.push(measureEntry);

					measureEntry.name = measure.internalKey;
					measureEntry.text = measure.text;
				});

				dimEntry.measures = measuresArray;
			} else {
				dimEntry.memberDisplay = ds.getMemberDisplay(element.name);
				dimEntry.showTotals = ds.getTotalsDisplay(element.name);
				dimEntry.hierarchies =  ds.getHierarchies(element.name);
				dimEntry.assignedHierarchy = ds.getAssignedHierarchy(element.name);
			}
		});

		var conditionalFormatsJson = [];
		var conditionalFormat = ds.getConditionalFormats();	// Issue Fix for Github Issue 22 reported by sschau
		conditionalFormat.forEach(function(element, index) {
		  var conditionalFormatJson = {};
		  conditionalFormatJson.push(conditionalFormatJson);
		  
		  conditionalFormatJson.id = element;
		  conditionalFormatJson.name = ds.getConditionalFormatName(element);
		  conditionalFormatJson.active = ds.isConditionalFormatActive(element);
		});
		
		var measureFiltersJson = [];
		var measureFilters = ds.getMeasureFilters();
		measureFilters.forEach(function(element, index) {
		  var conditionJson = {};
		  measureFiltersJson.push(conditionJson);
		  
		  measureFilterJson.id = element;
		  measureFilterJson.name = ds.getMeasureFilterName(element);
		  measureFilterJson.active = ds.isMeasureFilterActive(element);
		});
		
		var dataSourceMetaData = {};
		dataSourceMetaData.dimensions = dimensionsArray;
		dataSourceMetaData.conditionalFormats = conditionalFormatsJson;
		dataSourceMetaData.measureFilters = measureFiltersJson;
		
		var result = JSON.stringify(dataSourceMetaData);
		return result;
	*}
	
	@Visibility(private)
	void internalWriteLog(String log) {*
		// only for debugging
		var active = false;
	
		if(active) {
			APPLICATION.log(log);
		}
	*}

	/**
	 * DO NOT USE, ONLY FOR DEBUG ACTIVATION
	 */
	@Visibility(private)
	boolean isDebug(optional String componentName) {*
		// quick check here
		if(componentName == undefined) {
			if(this._dbgDEBUG == "+") { return true; }
			if(this._dbgDEBUG == "-") { return false; }
			componentName = "DEBUG";
		} else {
			if(this["_dbg" + componentName] == "+") { return true; }
			if(this["_dbg" + componentName] == "-") { return false; }
		}
	
		internal_assureGlobalAccess ();
		
		var something = this.getGlobal()[componentName];
		if(something != undefined) {
			this["_dbg" + componentName] == "+";
			return true;
		} else {
			this["_dbg" + componentName] == "-";
			return false;
		}
	*}
	
	/**
	 * Internal function to read return global scope
	 * http://stackoverflow.com/questions/1162998/how-can-i-add-an-object-property-to-the-global-object-in-rhino-javascript
	 */
	@Visibility(private)
	void internal_assureGlobalAccess () {*
		if(this.getGlobal == undefined) {
			this.getGlobal = function () {
				return (function() {
					return this;
				}).call(null);
			}
		}
	*}
	
	/**
	 * Converts Choice values to Strings
	 */
	@Visibility(private)
	String convertChoiceToString (String choice) {*
		return choice;
	*}

	/**
	 * Converts String values to Choices
	 */
	@Visibility(private)
	String convertToStringChoice (String value) {*
		value = value.toUpper();
		value = value.replace(" ", "_");
		return value;
	*}
}

class org.scn.community.shared.BufferDataSource extends SdkDataBuffer {
	
}/** GENERATED BY SAPUI5 CONTROLS DEFINITIONS */

/**
 * Generated ZTL Class for Breadcrumbs
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.Breadcrumbs extends org.scn.community.shared.DataComponent {

	/**
	 * Clean All Links from the Array.
	 */	
	void cleanAllLinks (){*
		this.cleanAllLinks = true;

		var elementsArray = [];
		this.links = JSON.stringify(elementsArray);
	*}

	/**
	 * Remove All Links from the Array.
	 * You can use also <code>cleanAllElements()</code>
	 */	
	@Visibility(deprecated)
	void removeAllLinks (){*
		this.cleanAllLinks = true;

		var elementsArray = [];
		this.links = JSON.stringify(elementsArray);
	*}



	/**
	 * Sets Current Location Text Property
	 */	
	void setCurrentLocationText( /**Current Location Text*/ String currentLocationText){*
		this.currentLocationText = currentLocationText;
	*}

	/**
	 * Gets Current Location Text Property
	 */	
	String getCurrentLocationText() {*
		return this.currentLocationText;
	*}



	/** Adds a root element containing key [String], text [String], textAlign [String], textDirection [String], wrapping [boolean], emphasized [boolean], enabled [boolean], subtle [boolean], href [String], target [String].

 	<example>
	You want to add 2 root elements
	<code>
	BREADCRUMBS.addLink(key [String], text [String], textAlign [String], textDirection [String], wrapping [boolean], emphasized [boolean], enabled [boolean], subtle [boolean], href [String], target [String]);<br>
	BREADCRUMBS.addLink(key [String], text [String], textAlign [String], textDirection [String], wrapping [boolean], emphasized [boolean], enabled [boolean], subtle [boolean], href [String], target [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addLink (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Text Align*/optional String textAlign, 
			/**Text Direction*/optional String textDirection, 
			/**Wrapping*/optional boolean wrapping, 
			/**Emphasized*/optional boolean emphasized, 
			/**Enabled*/optional boolean enabled, 
			/**Subtle*/optional boolean subtle, 
			/**Href*/optional String href, 
			/**Target*/optional String target
			) {*

		if(textAlign == undefined) { textAlign = "";}
		if(textDirection == undefined) { textDirection = "";}
		if(wrapping == undefined) { wrapping = false;}
		if(emphasized == undefined) { emphasized = false;}
		if(enabled == undefined) { enabled = true;}
		if(subtle == undefined) { subtle = false;}
		if(href == undefined) { href = "";}
		if(target == undefined) { target = "";}
		
		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			wrapping:wrapping, 
			emphasized:emphasized, 
			enabled:enabled, 
			subtle:subtle, 
			href:href, 
			target:target
			};

		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			this.links = "[]";
		}

		var elementsJson = JSON.parse(this.links);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BREADCRUMBS.removeLink(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeLink (
			String key
			) {*

		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			this.links = "[]";
		}

		var elementsJson = JSON.parse(this.links);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	BREADCRUMBS.insertLink(index [int], key [String], text [String], textAlign [String], textDirection [String], wrapping [boolean], emphasized [boolean], enabled [boolean], subtle [boolean], href [String], target [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertLink (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Text Align*/optional String textAlign, 
			/**Text Direction*/optional String textDirection, 
			/**Wrapping*/optional boolean wrapping, 
			/**Emphasized*/optional boolean emphasized, 
			/**Enabled*/optional boolean enabled, 
			/**Subtle*/optional boolean subtle, 
			/**Href*/optional String href, 
			/**Target*/optional String target
			) {*

		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			this.links = "[]";
		}
		
		var elementsJson = JSON.parse(this.links);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			wrapping:wrapping, 
			emphasized:emphasized, 
			enabled:enabled, 
			subtle:subtle, 
			href:href, 
			target:target
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.links = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Link<br/>
	 */
	void updateLink (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Text Align*/optional String textAlign, 
			/**Text Direction*/optional String textDirection, 
			/**Wrapping*/optional boolean wrapping, 
			/**Emphasized*/optional boolean emphasized, 
			/**Enabled*/optional boolean enabled, 
			/**Subtle*/optional boolean subtle, 
			/**Href*/optional String href, 
			/**Target*/optional String target
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			this.links = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			wrapping:wrapping, 
			emphasized:emphasized, 
			enabled:enabled, 
			subtle:subtle, 
			href:href, 
			target:target
		};

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLinkAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			this.links = "[]";
		}

		var elementsJson = JSON.parse(this.links);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Links As JSON String
	 */	
	String getLinksAsJSON() {*
		var jsonObject = JSON.parse(this.links);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Links
	 */	
	String cleanAllLinks() {*
		this.links = "[]";
	*}
	
	/**
	 * Sets the Text for Link keys<br/>
	 */
	void setLinkTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Link Key<br/>
	 */
	void setLinkText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Link Key<br/>
	 */
	String getLinkText (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the TextAlign for Link keys<br/>
	 */
	void setLinkTextAligns (
			/**/ String keys,
			/**/ String separator,
	        /* TextAlign */ String textAlign
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].textAlign = textAlign;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the TextAlign for Link Key<br/>
	 */
	void setLinkTextAlign (
			/**/ String key,
			/**/ String textAlign
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].textAlign = textAlign;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of TextAlign for Link Key<br/>
	 */
	String getLinkTextAlign (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].textAlign;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the TextDirection for Link keys<br/>
	 */
	void setLinkTextDirections (
			/**/ String keys,
			/**/ String separator,
	        /* TextDirection */ String textDirection
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].textDirection = textDirection;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the TextDirection for Link Key<br/>
	 */
	void setLinkTextDirection (
			/**/ String key,
			/**/ String textDirection
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].textDirection = textDirection;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of TextDirection for Link Key<br/>
	 */
	String getLinkTextDirection (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].textDirection;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Wrapping for Link keys<br/>
	 */
	void setLinkWrappings (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].wrapping = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].wrapping = true;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Wrapping for Link Key<br/>
	 */
	void setLinkWrapping (
			/**/ String key,
			/**/ boolean wrapping
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].wrapping = wrapping;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Wrapping of Link keys<br/>
	 */
	void cleanAllLinkWrappings (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].wrapping = false;
		}
		
		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Wrapping for Link Key<br/>
	 */
	String getLinkWrapping (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].wrapping;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Wrapping keys<br/>
	 */
	org.scn.community.shared.KeyArray getLinkWrappingKeysArray (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.links);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].wrapping == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Emphasized for Link keys<br/>
	 */
	void setLinkEmphasizeds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].emphasized = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].emphasized = true;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Emphasized for Link Key<br/>
	 */
	void setLinkEmphasized (
			/**/ String key,
			/**/ boolean emphasized
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].emphasized = emphasized;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Emphasized of Link keys<br/>
	 */
	void cleanAllLinkEmphasizeds (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].emphasized = false;
		}
		
		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Emphasized for Link Key<br/>
	 */
	String getLinkEmphasized (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].emphasized;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Emphasized keys<br/>
	 */
	org.scn.community.shared.KeyArray getLinkEmphasizedKeysArray (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.links);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].emphasized == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Enabled for Link keys<br/>
	 */
	void setLinkEnableds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].enabled = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].enabled = true;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Enabled for Link Key<br/>
	 */
	void setLinkEnabled (
			/**/ String key,
			/**/ boolean enabled
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].enabled = enabled;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Enabled of Link keys<br/>
	 */
	void cleanAllLinkEnableds (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].enabled = false;
		}
		
		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Enabled for Link Key<br/>
	 */
	String getLinkEnabled (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].enabled;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Enabled keys<br/>
	 */
	org.scn.community.shared.KeyArray getLinkEnabledKeysArray (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.links);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].enabled == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Subtle for Link keys<br/>
	 */
	void setLinkSubtles (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].subtle = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].subtle = true;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Subtle for Link Key<br/>
	 */
	void setLinkSubtle (
			/**/ String key,
			/**/ boolean subtle
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].subtle = subtle;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Subtle of Link keys<br/>
	 */
	void cleanAllLinkSubtles (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].subtle = false;
		}
		
		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Subtle for Link Key<br/>
	 */
	String getLinkSubtle (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].subtle;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Subtle keys<br/>
	 */
	org.scn.community.shared.KeyArray getLinkSubtleKeysArray (
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.links);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].subtle == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Href for Link keys<br/>
	 */
	void setLinkHrefs (
			/**/ String keys,
			/**/ String separator,
	        /* Href */ String href
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].href = href;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Href for Link Key<br/>
	 */
	void setLinkHref (
			/**/ String key,
			/**/ String href
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].href = href;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Href for Link Key<br/>
	 */
	String getLinkHref (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].href;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Target for Link keys<br/>
	 */
	void setLinkTargets (
			/**/ String keys,
			/**/ String separator,
	        /* Target */ String target
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.links);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].target = target;
					break;
				}
			}
		}
		
		this.links = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Target for Link Key<br/>
	 */
	void setLinkTarget (
			/**/ String key,
			/**/ String target
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].target = target;
				break;
			}
		}

		this.links = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Target for Link Key<br/>
	 */
	String getLinkTarget (
			/**/ String key
			) 
	{*
		if (this.links === undefined || this.links === "" || this.links === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.links);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].target;
				break;
			}
		}
		
		return value;
	*}





	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}






	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for BulletChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChart extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void setActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeActual(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearActual (
			
			) {*

		this.actual = "[]";
	*}

	/**
	 * Updates given Actual<br/>
	 */
	void updateActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getActual (
			
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Actuals As JSON String
	 */	
	String getActualsAsJSON() {*
		var jsonObject = JSON.parse(this.actual);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Actual keys<br/>
	 */
	void setActualColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.actual);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Actual Key<br/>
	 */
	void setActualColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for Actual Key<br/>
	 */
	String getActualColor (
			/**/ String key
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Value for Actual keys<br/>
	 */
	void setActualValues (
			/**/ String keys,
			/**/ String separator,
	        /* Value */ float value
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.actual);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].value = value;
					break;
				}
			}
		}
		
		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Value for Actual Key<br/>
	 */
	void setActualValue (
			/**/ String key,
			/**/ float value
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].value = value;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Value for Actual Key<br/>
	 */
	float getActualValue (
			/**/ String key
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].value;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Actual Value Label Property
	 */	
	void setActualValueLabel( /**Actual Value Label*/ String actualValueLabel){*
		this.actualValueLabel = actualValueLabel;
	*}

	/**
	 * Gets Actual Value Label Property
	 */	
	String getActualValueLabel() {*
		return this.actualValueLabel;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}













	/**
	 * Sets Delta Value Label Property
	 */	
	void setDeltaValueLabel( /**Delta Value Label*/ String deltaValueLabel){*
		this.deltaValueLabel = deltaValueLabel;
	*}

	/**
	 * Gets Delta Value Label Property
	 */	
	String getDeltaValueLabel() {*
		return this.deltaValueLabel;
	*}

	/**
	 * Sets Forecast Value Property
	 */	
	void setForecastValue( /**Forecast Value*/ float forecastValue){*
		this.forecastValue = forecastValue;
	*}

	/**
	 * Gets Forecast Value Property
	 */	
	float getForecastValue() {*
		return this.forecastValue;
	*}

	/**
	 * Sets Max Value Property
	 */	
	void setMaxValue( /**Max Value*/ float maxValue){*
		this.maxValue = maxValue;
	*}

	/**
	 * Gets Max Value Property
	 */	
	float getMaxValue() {*
		return this.maxValue;
	*}

	/**
	 * Sets Min Value Property
	 */	
	void setMinValue( /**Min Value*/ float minValue){*
		this.minValue = minValue;
	*}

	/**
	 * Gets Min Value Property
	 */	
	float getMinValue() {*
		return this.minValue;
	*}

	/**
	 * Sets Mode Property by String
	 */	
	void setModeByString( /**Mode*/ String mode){*
		this.mode = mode;
	*}

	/**
	 * Gets Mode Property as String
	 */	
	String getModeAsString() {*
		return this.mode;
	*}
	
	/**
	 * Sets Mode Property by Choice Option
	 */	
	void setMode( /**Mode*/ org_scn_community_shared_BulletChartModeEnumfield mode){*
		this.mode = mode;
	*}
	
	/**
	 * Gets Mode Property as Choice Option
	 */	
	org_scn_community_shared_BulletChartModeEnumfield getMode() {*
		return this.mode;
	*}



	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Sets Scale Property
	 */	
	void setScale( /**Scale*/ String scale){*
		this.scale = scale;
	*}

	/**
	 * Gets Scale Property
	 */	
	String getScale() {*
		return this.scale;
	*}

	/**
	 * Sets Scale Colour Property by String
	 */	
	void setScaleColorByString( /**Scale Colour*/ String scaleColor){*
		this.scaleColor = scaleColor;
	*}

	/**
	 * Gets Scale Colour Property as String
	 */	
	String getScaleColorAsString() {*
		return this.scaleColor;
	*}
	
	/**
	 * Sets Scale Colour Property by Choice Option
	 */	
	void setScaleColor( /**Scale Colour*/ org_scn_community_shared_CommonBackgroundEnumfield scaleColor){*
		this.scaleColor = scaleColor;
	*}
	
	/**
	 * Gets Scale Colour Property as Choice Option
	 */	
	org_scn_community_shared_CommonBackgroundEnumfield getScaleColor() {*
		return this.scaleColor;
	*}

	/**
	 * Sets Show Actual Value Property
	 */	
	void setShowActualValue( /**Show Actual Value*/ boolean showActualValue){*
		this.showActualValue = showActualValue;
	*}

	/**
	 * Gets Show Actual Value Property
	 */	
	boolean isShowActualValue() {*
		return this.showActualValue;
	*}

	/**
	 * Sets Show Delta Value Property
	 */	
	void setShowDeltaValue( /**Show Delta Value*/ boolean showDeltaValue){*
		this.showDeltaValue = showDeltaValue;
	*}

	/**
	 * Gets Show Delta Value Property
	 */	
	boolean isShowDeltaValue() {*
		return this.showDeltaValue;
	*}

	/**
	 * Sets Show Target Value Property
	 */	
	void setShowTargetValue( /**Show Target Value*/ boolean showTargetValue){*
		this.showTargetValue = showTargetValue;
	*}

	/**
	 * Gets Show Target Value Property
	 */	
	boolean isShowTargetValue() {*
		return this.showTargetValue;
	*}

	/**
	 * Sets Show Value Marker Property
	 */	
	void setShowValueMarker( /**Show Value Marker*/ boolean showValueMarker){*
		this.showValueMarker = showValueMarker;
	*}

	/**
	 * Gets Show Value Marker Property
	 */	
	boolean isShowValueMarker() {*
		return this.showValueMarker;
	*}

	/**
	 * Sets Size Property by String
	 */	
	void setSizeByString( /**Size*/ String size){*
		this.size = size;
	*}

	/**
	 * Gets Size Property as String
	 */	
	String getSizeAsString() {*
		return this.size;
	*}
	
	/**
	 * Sets Size Property by Choice Option
	 */	
	void setSize( /**Size*/ org_scn_community_shared_InfoTileSizeEnumfield size){*
		this.size = size;
	*}
	
	/**
	 * Gets Size Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileSizeEnumfield getSize() {*
		return this.size;
	*}

	/**
	 * Sets Target Value Property
	 */	
	void setTargetValue( /**Target Value*/ float targetValue){*
		this.targetValue = targetValue;
	*}

	/**
	 * Gets Target Value Property
	 */	
	float getTargetValue() {*
		return this.targetValue;
	*}

	/**
	 * Sets Target Value Label Property
	 */	
	void setTargetValueLabel( /**Target Value Label*/ String targetValueLabel){*
		this.targetValueLabel = targetValueLabel;
	*}

	/**
	 * Gets Target Value Label Property
	 */	
	String getTargetValueLabel() {*
		return this.targetValueLabel;
	*}

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeThreshold(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeThreshold (
			String key
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	BULLETCHART.insertThreshold(index [int], key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertThreshold (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}
		
		var elementsJson = JSON.parse(this.thresholds);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.thresholds = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Threshold<br/>
	 */
	void updateThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getThresholdAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Thresholds As JSON String
	 */	
	String getThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.thresholds);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Thresholds
	 */	
	String cleanAllThresholds() {*
		this.thresholds = "[]";
	*}
	
	/**
	 * Sets the Color for Threshold keys<br/>
	 */
	void setThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Threshold Key<br/>
	 */
	void setThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for Threshold Key<br/>
	 */
	String getThresholdColor (
			/**/ String key
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Value for Threshold keys<br/>
	 */
	void setThresholdValues (
			/**/ String keys,
			/**/ String separator,
	        /* Value */ float value
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].value = value;
					break;
				}
			}
		}
		
		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Value for Threshold Key<br/>
	 */
	void setThresholdValue (
			/**/ String key,
			/**/ float value
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].value = value;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Value for Threshold Key<br/>
	 */
	float getThresholdValue (
			/**/ String key
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].value;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Use Manual 'Actual' Property
	 */	
	void setUseActual( /**Use Manual 'Actual'*/ boolean useActual){*
		this.useActual = useActual;
	*}

	/**
	 * Gets Use Manual 'Actual' Property
	 */	
	boolean isUseActual() {*
		return this.useActual;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'Forecast Value' Property
	 */	
	void setUseForecastValue( /**Use Manual 'Forecast Value'*/ boolean useForecastValue){*
		this.useForecastValue = useForecastValue;
	*}

	/**
	 * Gets Use Manual 'Forecast Value' Property
	 */	
	boolean isUseForecastValue() {*
		return this.useForecastValue;
	*}

	/**
	 * Sets Use Manual 'Max Value' Property
	 */	
	void setUseMaxValue( /**Use Manual 'Max Value'*/ boolean useMaxValue){*
		this.useMaxValue = useMaxValue;
	*}

	/**
	 * Gets Use Manual 'Max Value' Property
	 */	
	boolean isUseMaxValue() {*
		return this.useMaxValue;
	*}

	/**
	 * Sets Use Manual 'Min Value' Property
	 */	
	void setUseMinValue( /**Use Manual 'Min Value'*/ boolean useMinValue){*
		this.useMinValue = useMinValue;
	*}

	/**
	 * Gets Use Manual 'Min Value' Property
	 */	
	boolean isUseMinValue() {*
		return this.useMinValue;
	*}

	/**
	 * Sets Use Manual 'Target Value' Property
	 */	
	void setUseTargetValue( /**Use Manual 'Target Value'*/ boolean useTargetValue){*
		this.useTargetValue = useTargetValue;
	*}

	/**
	 * Gets Use Manual 'Target Value' Property
	 */	
	boolean isUseTargetValue() {*
		return this.useTargetValue;
	*}

	/**
	 * Sets Use Manual 'Thresholds' Property
	 */	
	void setUseThresholds( /**Use Manual 'Thresholds'*/ boolean useThresholds){*
		this.useThresholds = useThresholds;
	*}

	/**
	 * Gets Use Manual 'Thresholds' Property
	 */	
	boolean isUseThresholds() {*
		return this.useThresholds;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for BulletChartData
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChartData extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}



	/**
	 * Sets Use Manual 'Value' Property
	 */	
	void setUseValue( /**Use Manual 'Value'*/ boolean useValue){*
		this.useValue = useValue;
	*}

	/**
	 * Gets Use Manual 'Value' Property
	 */	
	boolean isUseValue() {*
		return this.useValue;
	*}

	/**
	 * Sets Value Property
	 */	
	void setValue( /**Value*/ float value){*
		this.value = value;
	*}

	/**
	 * Gets Value Property
	 */	
	float getValue() {*
		return this.value;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for BusyDialog
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BusyDialog extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Close Button Text Property
	 */	
	void setCancelButtonText( /**Close Button Text*/ String cancelButtonText){*
		this.cancelButtonText = cancelButtonText;
	*}

	/**
	 * Gets Close Button Text Property
	 */	
	String getCancelButtonText() {*
		return this.cancelButtonText;
	*}

	/**
	 * Sets Custom Icon Property
	 */	
	void setCustomIcon( /**Custom Icon*/ String customIcon){*
		this.customIcon = customIcon;
	*}

	/**
	 * Gets Custom Icon Property
	 */	
	String getCustomIcon() {*
		return this.customIcon;
	*}

	/**
	 * Sets Custom Icon Density Aware Property
	 */	
	void setCustomIconDensityAware( /**Custom Icon Density Aware*/ boolean customIconDensityAware){*
		this.customIconDensityAware = customIconDensityAware;
	*}

	/**
	 * Gets Custom Icon Density Aware Property
	 */	
	boolean isCustomIconDensityAware() {*
		return this.customIconDensityAware;
	*}

	/**
	 * Sets Custom Icon Height Property
	 */	
	void setCustomIconHeight( /**Custom Icon Height*/ int customIconHeight){*
		this.customIconHeight = customIconHeight;
	*}

	/**
	 * Gets Custom Icon Height Property
	 */	
	int getCustomIconHeight() {*
		return this.customIconHeight;
	*}

	/**
	 * Sets Custom Icon Rotation Speed Property
	 */	
	void setCustomIconRotationSpeed( /**Custom Icon Rotation Speed*/ int customIconRotationSpeed){*
		this.customIconRotationSpeed = customIconRotationSpeed;
	*}

	/**
	 * Gets Custom Icon Rotation Speed Property
	 */	
	int getCustomIconRotationSpeed() {*
		return this.customIconRotationSpeed;
	*}

	/**
	 * Sets Custom Icon Width Property
	 */	
	void setCustomIconWidth( /**Custom Icon Width*/ int customIconWidth){*
		this.customIconWidth = customIconWidth;
	*}

	/**
	 * Gets Custom Icon Width Property
	 */	
	int getCustomIconWidth() {*
		return this.customIconWidth;
	*}



	/**
	 * Sets Show Close Button Property
	 */	
	void setShowCancelButton( /**Show Close Button*/ boolean showCancelButton){*
		this.showCancelButton = showCancelButton;
	*}

	/**
	 * Gets Show Close Button Property
	 */	
	boolean isShowCancelButton() {*
		return this.showCancelButton;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Title Property
	 */	
	void setTitle( /**Title*/ String title){*
		this.title = title;
	*}

	/**
	 * Gets Title Property
	 */	
	String getTitle() {*
		return this.title;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for CalendarAppointment
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.CalendarAppointment extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Icon Property
	 */	
	void setIcon( /**Icon*/ String icon){*
		this.icon = icon;
	*}

	/**
	 * Gets Icon Property
	 */	
	String getIcon() {*
		return this.icon;
	*}

	/**
	 * Sets Key Property
	 */	
	void setKey( /**Key*/ String key){*
		this.key = key;
	*}

	/**
	 * Gets Key Property
	 */	
	String getKey() {*
		return this.key;
	*}

	/**
	 * Sets Selected Property
	 */	
	void setSelected( /**Selected*/ boolean selected){*
		this.selected = selected;
	*}

	/**
	 * Gets Selected Property
	 */	
	boolean isSelected() {*
		return this.selected;
	*}

	/**
	 * Sets Tentative Property
	 */	
	void setTentative( /**Tentative*/ boolean tentative){*
		this.tentative = tentative;
	*}

	/**
	 * Gets Tentative Property
	 */	
	boolean isTentative() {*
		return this.tentative;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Title Property
	 */	
	void setTitle( /**Title*/ String title){*
		this.title = title;
	*}

	/**
	 * Gets Title Property
	 */	
	String getTitle() {*
		return this.title;
	*}

	/**
	 * Sets Use Manual 'Icon' Property
	 */	
	void setUseIcon( /**Use Manual 'Icon'*/ boolean useIcon){*
		this.useIcon = useIcon;
	*}

	/**
	 * Gets Use Manual 'Icon' Property
	 */	
	boolean isUseIcon() {*
		return this.useIcon;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for HarveyBallMicroChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.HarveyBallMicroChart extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Palette Property as StringArray
	 */	
	void setColorPalette( /**Colour Palette*/ StringArray colorPalette){*
		this.colorPalette = colorPalette;
	*}
	
	/** Gets Colour Palette Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	HARVEYBALLMICROCHART.getColorPalette();<br>
	</code>
	</example>
	 */
	StringArray getColorPalette () {*		
		var elementsJson = JSON.parse(this.colorPalette);
		return elementsJson;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}





	/**
	 * Sets Formatted Label Property
	 */	
	void setFormattedLabel( /**Formatted Label*/ boolean formattedLabel){*
		this.formattedLabel = formattedLabel;
	*}

	/**
	 * Gets Formatted Label Property
	 */	
	boolean isFormattedLabel() {*
		return this.formattedLabel;
	*}

	/** Adds a root element containing key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String].

 	<example>
	You want to add 2 root elements
	<code>
	HARVEYBALLMICROCHART.addItem(key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	HARVEYBALLMICROCHART.addItem(key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addItem (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/optional String fractionLabel, 
			/**Fraction Scale*/optional String fractionScale
			) {*

		if(fractionLabel == undefined) { fractionLabel = "";}
		if(fractionScale == undefined) { fractionScale = "";}
		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
			};

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	HARVEYBALLMICROCHART.removeItem(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeItem (
			String key
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	HARVEYBALLMICROCHART.insertItem(index [int], key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertItem (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/optional String fractionLabel, 
			/**Fraction Scale*/optional String fractionScale
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}
		
		var elementsJson = JSON.parse(this.items);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.items = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Item<br/>
	 */
	void updateItem (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/optional String fractionLabel, 
			/**Fraction Scale*/optional String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
		};

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getItemAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Items As JSON String
	 */	
	String getItemsAsJSON() {*
		var jsonObject = JSON.parse(this.items);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Items
	 */	
	String cleanAllItems() {*
		this.items = "[]";
	*}
	
	/**
	 * Sets the Color for Item keys<br/>
	 */
	void setItemColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Item Key<br/>
	 */
	void setItemColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for Item Key<br/>
	 */
	String getItemColor (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the FormattedLabel for Item keys<br/>
	 */
	void setItemFormattedLabels (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].formattedLabel = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].formattedLabel = true;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FormattedLabel for Item Key<br/>
	 */
	void setItemFormattedLabel (
			/**/ String key,
			/**/ boolean formattedLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].formattedLabel = formattedLabel;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all FormattedLabel of Item keys<br/>
	 */
	void cleanAllItemFormattedLabels (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].formattedLabel = false;
		}
		
		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of FormattedLabel for Item Key<br/>
	 */
	String getItemFormattedLabel (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].formattedLabel;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the FormattedLabel keys<br/>
	 */
	org.scn.community.shared.KeyArray getItemFormattedLabelKeysArray (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.items);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].formattedLabel == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Fraction for Item keys<br/>
	 */
	void setItemFractions (
			/**/ String keys,
			/**/ String separator,
	        /* Fraction */ float fraction
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fraction = fraction;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Fraction for Item Key<br/>
	 */
	void setItemFraction (
			/**/ String key,
			/**/ float fraction
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fraction = fraction;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Fraction for Item Key<br/>
	 */
	float getItemFraction (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].fraction;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the FractionLabel for Item keys<br/>
	 */
	void setItemFractionLabels (
			/**/ String keys,
			/**/ String separator,
	        /* FractionLabel */ String fractionLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fractionLabel = fractionLabel;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FractionLabel for Item Key<br/>
	 */
	void setItemFractionLabel (
			/**/ String key,
			/**/ String fractionLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fractionLabel = fractionLabel;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of FractionLabel for Item Key<br/>
	 */
	String getItemFractionLabel (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].fractionLabel;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the FractionScale for Item keys<br/>
	 */
	void setItemFractionScales (
			/**/ String keys,
			/**/ String separator,
	        /* FractionScale */ String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fractionScale = fractionScale;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FractionScale for Item Key<br/>
	 */
	void setItemFractionScale (
			/**/ String key,
			/**/ String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fractionScale = fractionScale;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of FractionScale for Item Key<br/>
	 */
	String getItemFractionScale (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].fractionScale;
				break;
			}
		}
		
		return value;
	*}





	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Sets Show Fractions Property
	 */	
	void setShowFractions( /**Show Fractions*/ boolean showFractions){*
		this.showFractions = showFractions;
	*}

	/**
	 * Gets Show Fractions Property
	 */	
	boolean isShowFractions() {*
		return this.showFractions;
	*}

	/**
	 * Sets Show Total Property
	 */	
	void setShowTotal( /**Show Total*/ boolean showTotal){*
		this.showTotal = showTotal;
	*}

	/**
	 * Gets Show Total Property
	 */	
	boolean isShowTotal() {*
		return this.showTotal;
	*}

	/**
	 * Sets Size Property by String
	 */	
	void setSizeByString( /**Size*/ String size){*
		this.size = size;
	*}

	/**
	 * Gets Size Property as String
	 */	
	String getSizeAsString() {*
		return this.size;
	*}
	
	/**
	 * Sets Size Property by Choice Option
	 */	
	void setSize( /**Size*/ org_scn_community_shared_InfoTileSizeEnumfield size){*
		this.size = size;
	*}
	
	/**
	 * Gets Size Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileSizeEnumfield getSize() {*
		return this.size;
	*}

	/**
	 * Sets Total Property
	 */	
	void setTotal( /**Total*/ float total){*
		this.total = total;
	*}

	/**
	 * Gets Total Property
	 */	
	float getTotal() {*
		return this.total;
	*}

	/**
	 * Sets Total Label Property
	 */	
	void setTotalLabel( /**Total Label*/ String totalLabel){*
		this.totalLabel = totalLabel;
	*}

	/**
	 * Gets Total Label Property
	 */	
	String getTotalLabel() {*
		return this.totalLabel;
	*}

	/**
	 * Sets Total Scale Property
	 */	
	void setTotalScale( /**Total Scale*/ String totalScale){*
		this.totalScale = totalScale;
	*}

	/**
	 * Gets Total Scale Property
	 */	
	String getTotalScale() {*
		return this.totalScale;
	*}

	/**
	 * Sets Use Manual 'Colour Palette' Property
	 */	
	void setUseColorPalette( /**Use Manual 'Colour Palette'*/ boolean useColorPalette){*
		this.useColorPalette = useColorPalette;
	*}

	/**
	 * Gets Use Manual 'Colour Palette' Property
	 */	
	boolean isUseColorPalette() {*
		return this.useColorPalette;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'Items' Property
	 */	
	void setUseItems( /**Use Manual 'Items'*/ boolean useItems){*
		this.useItems = useItems;
	*}

	/**
	 * Gets Use Manual 'Items' Property
	 */	
	boolean isUseItems() {*
		return this.useItems;
	*}

	/**
	 * Sets Use Manual 'Total' Property
	 */	
	void setUseTotal( /**Use Manual 'Total'*/ boolean useTotal){*
		this.useTotal = useTotal;
	*}

	/**
	 * Gets Use Manual 'Total' Property
	 */	
	boolean isUseTotal() {*
		return this.useTotal;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for HarveyBallMicroChartItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.HarveyBallMicroChartItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}



	/**
	 * Sets Formatted Label Property
	 */	
	void setFormattedLabel( /**Formatted Label*/ boolean formattedLabel){*
		this.formattedLabel = formattedLabel;
	*}

	/**
	 * Gets Formatted Label Property
	 */	
	boolean isFormattedLabel() {*
		return this.formattedLabel;
	*}

	/**
	 * Sets Fraction Property
	 */	
	void setFraction( /**Fraction*/ float fraction){*
		this.fraction = fraction;
	*}

	/**
	 * Gets Fraction Property
	 */	
	float getFraction() {*
		return this.fraction;
	*}

	/**
	 * Sets Fraction Label Property
	 */	
	void setFractionLabel( /**Fraction Label*/ String fractionLabel){*
		this.fractionLabel = fractionLabel;
	*}

	/**
	 * Gets Fraction Label Property
	 */	
	String getFractionLabel() {*
		return this.fractionLabel;
	*}

	/**
	 * Sets Fraction Scale Property
	 */	
	void setFractionScale( /**Fraction Scale*/ String fractionScale){*
		this.fractionScale = fractionScale;
	*}

	/**
	 * Gets Fraction Scale Property
	 */	
	String getFractionScale() {*
		return this.fractionScale;
	*}

	/**
	 * Sets Use Manual 'Fraction' Property
	 */	
	void setUseFraction( /**Use Manual 'Fraction'*/ boolean useFraction){*
		this.useFraction = useFraction;
	*}

	/**
	 * Gets Use Manual 'Fraction' Property
	 */	
	boolean isUseFraction() {*
		return this.useFraction;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for Link
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.Link extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/**
	 * Sets Emphasized Property
	 */	
	void setEmphasized( /**Emphasized*/ boolean emphasized){*
		this.emphasized = emphasized;
	*}

	/**
	 * Gets Emphasized Property
	 */	
	boolean isEmphasized() {*
		return this.emphasized;
	*}

	/**
	 * Sets Enabled Property
	 */	
	void setEnabled( /**Enabled*/ boolean enabled){*
		this.enabled = enabled;
	*}

	/**
	 * Gets Enabled Property
	 */	
	boolean isEnabled() {*
		return this.enabled;
	*}

	/**
	 * Sets Href Property
	 */	
	void setHref( /**Href*/ String href){*
		this.href = href;
	*}

	/**
	 * Gets Href Property
	 */	
	String getHref() {*
		return this.href;
	*}



	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Sets Subtle Property
	 */	
	void setSubtle( /**Subtle*/ boolean subtle){*
		this.subtle = subtle;
	*}

	/**
	 * Gets Subtle Property
	 */	
	boolean isSubtle() {*
		return this.subtle;
	*}

	/**
	 * Sets Target Property
	 */	
	void setTarget( /**Target*/ String target){*
		this.target = target;
	*}

	/**
	 * Gets Target Property
	 */	
	String getTarget() {*
		return this.target;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Text Align Property by String
	 */	
	void setTextAlignByString( /**Text Align*/ String textAlign){*
		this.textAlign = textAlign;
	*}

	/**
	 * Gets Text Align Property as String
	 */	
	String getTextAlignAsString() {*
		return this.textAlign;
	*}
	
	/**
	 * Sets Text Align Property by Choice Option
	 */	
	void setTextAlign( /**Text Align*/ org_scn_community_shared_TextAlignEnumfield textAlign){*
		this.textAlign = textAlign;
	*}
	
	/**
	 * Gets Text Align Property as Choice Option
	 */	
	org_scn_community_shared_TextAlignEnumfield getTextAlign() {*
		return this.textAlign;
	*}

	/**
	 * Sets Text Direction Property by String
	 */	
	void setTextDirectionByString( /**Text Direction*/ String textDirection){*
		this.textDirection = textDirection;
	*}

	/**
	 * Gets Text Direction Property as String
	 */	
	String getTextDirectionAsString() {*
		return this.textDirection;
	*}
	
	/**
	 * Sets Text Direction Property by Choice Option
	 */	
	void setTextDirection( /**Text Direction*/ org_scn_community_shared_TextDirectionEnumfield textDirection){*
		this.textDirection = textDirection;
	*}
	
	/**
	 * Gets Text Direction Property as Choice Option
	 */	
	org_scn_community_shared_TextDirectionEnumfield getTextDirection() {*
		return this.textDirection;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'Href' Property
	 */	
	void setUseHref( /**Use Manual 'Href'*/ boolean useHref){*
		this.useHref = useHref;
	*}

	/**
	 * Gets Use Manual 'Href' Property
	 */	
	boolean isUseHref() {*
		return this.useHref;
	*}

	/**
	 * Sets Wrapping Property
	 */	
	void setWrapping( /**Wrapping*/ boolean wrapping){*
		this.wrapping = wrapping;
	*}

	/**
	 * Gets Wrapping Property
	 */	
	boolean isWrapping() {*
		return this.wrapping;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChart extends org.scn.community.shared.DataComponent {

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setChart(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setChart (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearChart();<br>
	<br>
	</code>
	</example>
	 */
	void clearChart (
			
			) {*		
		
		this.chart = "[]";
	*}

	/**
	 * Gets Charts As JSON String
	 */	
	String getChartsAsJSON() {*
		var jsonObject = JSON.parse(this.chart);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Charts
	 */	
	String cleanAllCharts() {*
		this.chart = "[]";
	*}
	
	/**
	 * Sets the Color for Chart keys<br/>
	 */
	void setChartColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.chart);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.chart = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Chart Key<br/>
	 */
	void setChartColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for Chart Key<br/>
	 */
	String getChartColor (
			/**/ String key
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.chart);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.chart = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.chart);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.chart = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Content Height Property
	 */	
	void setContentHeight( /**Content Height*/ int contentHeight){*
		this.contentHeight = contentHeight;
	*}

	/**
	 * Gets Content Height Property
	 */	
	int getContentHeight() {*
		return this.contentHeight;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

































	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstXLabel (
			
			) {*

		this.firstXLabel = "[]";
	*}

	/**
	 * Updates given FirstXLabel<br/>
	 */
	void updateFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstXLabel (
			
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstXLabels As JSON String
	 */	
	String getFirstXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstXLabel keys<br/>
	 */
	void setFirstXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstXLabel Key<br/>
	 */
	void setFirstXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for FirstXLabel Key<br/>
	 */
	String getFirstXLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for FirstXLabel keys<br/>
	 */
	void setFirstXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstXLabel Key<br/>
	 */
	void setFirstXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for FirstXLabel Key<br/>
	 */
	String getFirstXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstYLabel (
			
			) {*

		this.firstYLabel = "[]";
	*}

	/**
	 * Updates given FirstYLabel<br/>
	 */
	void updateFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstYLabel (
			
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstYLabels As JSON String
	 */	
	String getFirstYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstYLabel keys<br/>
	 */
	void setFirstYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstYLabel Key<br/>
	 */
	void setFirstYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for FirstYLabel Key<br/>
	 */
	String getFirstYLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for FirstYLabel keys<br/>
	 */
	void setFirstYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstYLabel Key<br/>
	 */
	void setFirstYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for FirstYLabel Key<br/>
	 */
	String getFirstYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMaxThreshold (
			
			) {*		
		
		this.innerMaxThreshold = "[]";
	*}

	/**
	 * Gets InnerMaxThresholds As JSON String
	 */	
	String getInnerMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMaxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All InnerMaxThresholds
	 */	
	String cleanAllInnerMaxThresholds() {*
		this.innerMaxThreshold = "[]";
	*}
	
	/**
	 * Sets the Color for InnerMaxThreshold keys<br/>
	 */
	void setInnerMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMaxThreshold Key<br/>
	 */
	void setInnerMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for InnerMaxThreshold Key<br/>
	 */
	String getInnerMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMinThreshold (
			
			) {*		
		
		this.innerMinThreshold = "[]";
	*}

	/**
	 * Gets InnerMinThresholds As JSON String
	 */	
	String getInnerMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMinThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All InnerMinThresholds
	 */	
	String cleanAllInnerMinThresholds() {*
		this.innerMinThreshold = "[]";
	*}
	
	/**
	 * Sets the Color for InnerMinThreshold keys<br/>
	 */
	void setInnerMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMinThreshold Key<br/>
	 */
	void setInnerMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for InnerMinThreshold Key<br/>
	 */
	String getInnerMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastXLabel (
			
			) {*

		this.lastXLabel = "[]";
	*}

	/**
	 * Updates given LastXLabel<br/>
	 */
	void updateLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastXLabel (
			
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastXLabels As JSON String
	 */	
	String getLastXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastXLabel keys<br/>
	 */
	void setLastXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastXLabel Key<br/>
	 */
	void setLastXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for LastXLabel Key<br/>
	 */
	String getLastXLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for LastXLabel keys<br/>
	 */
	void setLastXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastXLabel Key<br/>
	 */
	void setLastXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for LastXLabel Key<br/>
	 */
	String getLastXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastYLabel (
			
			) {*

		this.lastYLabel = "[]";
	*}

	/**
	 * Updates given LastYLabel<br/>
	 */
	void updateLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastYLabel (
			
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastYLabels As JSON String
	 */	
	String getLastYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastYLabel keys<br/>
	 */
	void setLastYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastYLabel Key<br/>
	 */
	void setLastYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for LastYLabel Key<br/>
	 */
	String getLastYLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for LastYLabel keys<br/>
	 */
	void setLastYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastYLabel Key<br/>
	 */
	void setLastYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for LastYLabel Key<br/>
	 */
	String getLastYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMaxLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxLabel (
			
			) {*

		this.maxLabel = "[]";
	*}

	/**
	 * Updates given MaxLabel<br/>
	 */
	void updateMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMaxLabel (
			
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MaxLabels As JSON String
	 */	
	String getMaxLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.maxLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MaxLabel keys<br/>
	 */
	void setMaxLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxLabel Key<br/>
	 */
	void setMaxLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for MaxLabel Key<br/>
	 */
	String getMaxLabelColor (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for MaxLabel keys<br/>
	 */
	void setMaxLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MaxLabel Key<br/>
	 */
	void setMaxLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for MaxLabel Key<br/>
	 */
	String getMaxLabelLabel (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxThreshold (
			
			) {*		
		
		this.maxThreshold = "[]";
	*}

	/**
	 * Gets MaxThresholds As JSON String
	 */	
	String getMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.maxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All MaxThresholds
	 */	
	String cleanAllMaxThresholds() {*
		this.maxThreshold = "[]";
	*}
	
	/**
	 * Sets the Color for MaxThreshold keys<br/>
	 */
	void setMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxThreshold Key<br/>
	 */
	void setMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for MaxThreshold Key<br/>
	 */
	String getMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Max X Value Property
	 */	
	void setMaxXValue( /**Max X Value*/ float maxXValue){*
		this.maxXValue = maxXValue;
	*}

	/**
	 * Gets Max X Value Property
	 */	
	float getMaxXValue() {*
		return this.maxXValue;
	*}

	/**
	 * Sets Max Y Value Property
	 */	
	void setMaxYValue( /**Max Y Value*/ float maxYValue){*
		this.maxYValue = maxYValue;
	*}

	/**
	 * Gets Max Y Value Property
	 */	
	float getMaxYValue() {*
		return this.maxYValue;
	*}

	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMinLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMinLabel (
			
			) {*

		this.minLabel = "[]";
	*}

	/**
	 * Updates given MinLabel<br/>
	 */
	void updateMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMinLabel (
			
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MinLabels As JSON String
	 */	
	String getMinLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.minLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MinLabel keys<br/>
	 */
	void setMinLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinLabel Key<br/>
	 */
	void setMinLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for MinLabel Key<br/>
	 */
	String getMinLabelColor (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Label for MinLabel keys<br/>
	 */
	void setMinLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MinLabel Key<br/>
	 */
	void setMinLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Label for MinLabel Key<br/>
	 */
	String getMinLabelLabel (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].label;
				break;
			}
		}
		
		return value;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMinThreshold (
			
			) {*		
		
		this.minThreshold = "[]";
	*}

	/**
	 * Gets MinThresholds As JSON String
	 */	
	String getMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.minThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All MinThresholds
	 */	
	String cleanAllMinThresholds() {*
		this.minThreshold = "[]";
	*}
	
	/**
	 * Sets the Color for MinThreshold keys<br/>
	 */
	void setMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinThreshold Key<br/>
	 */
	void setMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for MinThreshold Key<br/>
	 */
	String getMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Min X Value Property
	 */	
	void setMinXValue( /**Min X Value*/ float minXValue){*
		this.minXValue = minXValue;
	*}

	/**
	 * Gets Min X Value Property
	 */	
	float getMinXValue() {*
		return this.minXValue;
	*}

	/**
	 * Sets Min Y Value Property
	 */	
	void setMinYValue( /**Min Y Value*/ float minYValue){*
		this.minYValue = minYValue;
	*}

	/**
	 * Gets Min Y Value Property
	 */	
	float getMinYValue() {*
		return this.minYValue;
	*}



	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setTarget(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setTarget (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearTarget();<br>
	<br>
	</code>
	</example>
	 */
	void clearTarget (
			
			) {*		
		
		this.target = "[]";
	*}

	/**
	 * Gets Targets As JSON String
	 */	
	String getTargetsAsJSON() {*
		var jsonObject = JSON.parse(this.target);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Targets
	 */	
	String cleanAllTargets() {*
		this.target = "[]";
	*}
	
	/**
	 * Sets the Color for Target keys<br/>
	 */
	void setTargetColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.target);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.target = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Target Key<br/>
	 */
	void setTargetColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Color for Target Key<br/>
	 */
	String getTargetColor (
			/**/ String key
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].color;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the X for Points keys<br/>
	 */
	void setPointsXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.target);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.target = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Points Key<br/>
	 */
	void setPointsX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Points Key<br/>
	 */
	float getPointsX (
			/**/ String key
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Points keys<br/>
	 */
	void setPointsYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.target);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.target = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Points Key<br/>
	 */
	void setPointsY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Points Key<br/>
	 */
	float getPointsY (
			/**/ String key
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Use Manual 'Chart' Property
	 */	
	void setUseChart( /**Use Manual 'Chart'*/ boolean useChart){*
		this.useChart = useChart;
	*}

	/**
	 * Gets Use Manual 'Chart' Property
	 */	
	boolean isUseChart() {*
		return this.useChart;
	*}

	/**
	 * Sets Use Manual 'Content Height' Property
	 */	
	void setUseContentHeight( /**Use Manual 'Content Height'*/ boolean useContentHeight){*
		this.useContentHeight = useContentHeight;
	*}

	/**
	 * Gets Use Manual 'Content Height' Property
	 */	
	boolean isUseContentHeight() {*
		return this.useContentHeight;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'First X Label' Property
	 */	
	void setUseFirstXLabel( /**Use Manual 'First X Label'*/ boolean useFirstXLabel){*
		this.useFirstXLabel = useFirstXLabel;
	*}

	/**
	 * Gets Use Manual 'First X Label' Property
	 */	
	boolean isUseFirstXLabel() {*
		return this.useFirstXLabel;
	*}

	/**
	 * Sets Use Manual 'First Y Label' Property
	 */	
	void setUseFirstYLabel( /**Use Manual 'First Y Label'*/ boolean useFirstYLabel){*
		this.useFirstYLabel = useFirstYLabel;
	*}

	/**
	 * Gets Use Manual 'First Y Label' Property
	 */	
	boolean isUseFirstYLabel() {*
		return this.useFirstYLabel;
	*}

	/**
	 * Sets Use Manual 'Inner Max Threshold' Property
	 */	
	void setUseInnerMaxThreshold( /**Use Manual 'Inner Max Threshold'*/ boolean useInnerMaxThreshold){*
		this.useInnerMaxThreshold = useInnerMaxThreshold;
	*}

	/**
	 * Gets Use Manual 'Inner Max Threshold' Property
	 */	
	boolean isUseInnerMaxThreshold() {*
		return this.useInnerMaxThreshold;
	*}

	/**
	 * Sets Use Manual 'Inner Min Threshold' Property
	 */	
	void setUseInnerMinThreshold( /**Use Manual 'Inner Min Threshold'*/ boolean useInnerMinThreshold){*
		this.useInnerMinThreshold = useInnerMinThreshold;
	*}

	/**
	 * Gets Use Manual 'Inner Min Threshold' Property
	 */	
	boolean isUseInnerMinThreshold() {*
		return this.useInnerMinThreshold;
	*}

	/**
	 * Sets Use Manual 'Last X Label' Property
	 */	
	void setUseLastXLabel( /**Use Manual 'Last X Label'*/ boolean useLastXLabel){*
		this.useLastXLabel = useLastXLabel;
	*}

	/**
	 * Gets Use Manual 'Last X Label' Property
	 */	
	boolean isUseLastXLabel() {*
		return this.useLastXLabel;
	*}

	/**
	 * Sets Use Manual 'Last Y Label' Property
	 */	
	void setUseLastYLabel( /**Use Manual 'Last Y Label'*/ boolean useLastYLabel){*
		this.useLastYLabel = useLastYLabel;
	*}

	/**
	 * Gets Use Manual 'Last Y Label' Property
	 */	
	boolean isUseLastYLabel() {*
		return this.useLastYLabel;
	*}

	/**
	 * Sets Use Manual 'Max Label' Property
	 */	
	void setUseMaxLabel( /**Use Manual 'Max Label'*/ boolean useMaxLabel){*
		this.useMaxLabel = useMaxLabel;
	*}

	/**
	 * Gets Use Manual 'Max Label' Property
	 */	
	boolean isUseMaxLabel() {*
		return this.useMaxLabel;
	*}

	/**
	 * Sets Use Manual 'Max Threshold' Property
	 */	
	void setUseMaxThreshold( /**Use Manual 'Max Threshold'*/ boolean useMaxThreshold){*
		this.useMaxThreshold = useMaxThreshold;
	*}

	/**
	 * Gets Use Manual 'Max Threshold' Property
	 */	
	boolean isUseMaxThreshold() {*
		return this.useMaxThreshold;
	*}

	/**
	 * Sets Use Manual 'Max X Value' Property
	 */	
	void setUseMaxXValue( /**Use Manual 'Max X Value'*/ boolean useMaxXValue){*
		this.useMaxXValue = useMaxXValue;
	*}

	/**
	 * Gets Use Manual 'Max X Value' Property
	 */	
	boolean isUseMaxXValue() {*
		return this.useMaxXValue;
	*}

	/**
	 * Sets Use Manual 'Max Y Value' Property
	 */	
	void setUseMaxYValue( /**Use Manual 'Max Y Value'*/ boolean useMaxYValue){*
		this.useMaxYValue = useMaxYValue;
	*}

	/**
	 * Gets Use Manual 'Max Y Value' Property
	 */	
	boolean isUseMaxYValue() {*
		return this.useMaxYValue;
	*}

	/**
	 * Sets Use Manual 'Min Label' Property
	 */	
	void setUseMinLabel( /**Use Manual 'Min Label'*/ boolean useMinLabel){*
		this.useMinLabel = useMinLabel;
	*}

	/**
	 * Gets Use Manual 'Min Label' Property
	 */	
	boolean isUseMinLabel() {*
		return this.useMinLabel;
	*}

	/**
	 * Sets Use Manual 'Min Threshold' Property
	 */	
	void setUseMinThreshold( /**Use Manual 'Min Threshold'*/ boolean useMinThreshold){*
		this.useMinThreshold = useMinThreshold;
	*}

	/**
	 * Gets Use Manual 'Min Threshold' Property
	 */	
	boolean isUseMinThreshold() {*
		return this.useMinThreshold;
	*}

	/**
	 * Sets Use Manual 'Min X Value' Property
	 */	
	void setUseMinXValue( /**Use Manual 'Min X Value'*/ boolean useMinXValue){*
		this.useMinXValue = useMinXValue;
	*}

	/**
	 * Gets Use Manual 'Min X Value' Property
	 */	
	boolean isUseMinXValue() {*
		return this.useMinXValue;
	*}

	/**
	 * Sets Use Manual 'Min Y Value' Property
	 */	
	void setUseMinYValue( /**Use Manual 'Min Y Value'*/ boolean useMinYValue){*
		this.useMinYValue = useMinYValue;
	*}

	/**
	 * Gets Use Manual 'Min Y Value' Property
	 */	
	boolean isUseMinYValue() {*
		return this.useMinYValue;
	*}

	/**
	 * Sets Use Manual 'Target' Property
	 */	
	void setUseTarget( /**Use Manual 'Target'*/ boolean useTarget){*
		this.useTarget = useTarget;
	*}

	/**
	 * Gets Use Manual 'Target' Property
	 */	
	boolean isUseTarget() {*
		return this.useTarget;
	*}

	/**
	 * Sets View Property by String
	 */	
	void setViewByString( /**View*/ String view){*
		this.view = view;
	*}

	/**
	 * Gets View Property as String
	 */	
	String getViewAsString() {*
		return this.view;
	*}
	
	/**
	 * Sets View Property by Choice Option
	 */	
	void setView( /**View*/ org_scn_community_shared_MicroAreaChartViewEnumfield view){*
		this.view = view;
	*}
	
	/**
	 * Gets View Property as Choice Option
	 */	
	org_scn_community_shared_MicroAreaChartViewEnumfield getView() {*
		return this.view;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}



	/** Adds a root element containing key [String], x [float], y [float].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addPoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
			};

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.points = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHARTITEM.removePoint(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removePoint (
			String key
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	MICROAREACHARTITEM.insertPoint(index [int], key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertPoint (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}
		
		var elementsJson = JSON.parse(this.points);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.points = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Point<br/>
	 */
	void updatePoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		var elementsJson = JSON.parse(this.points);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getPointAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Points As JSON String
	 */	
	String getPointsAsJSON() {*
		var jsonObject = JSON.parse(this.points);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Points
	 */	
	String cleanAllPoints() {*
		this.points = "[]";
	*}
	
	/**
	 * Sets the X for Point keys<br/>
	 */
	void setPointXs (
			/**/ String keys,
			/**/ String separator,
	        /* X */ float x
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.points);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].x = x;
					break;
				}
			}
		}
		
		this.points = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the X for Point Key<br/>
	 */
	void setPointX (
			/**/ String key,
			/**/ float x
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.points);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].x = x;
				break;
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of X for Point Key<br/>
	 */
	float getPointX (
			/**/ String key
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.points);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].x;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Y for Point keys<br/>
	 */
	void setPointYs (
			/**/ String keys,
			/**/ String separator,
	        /* Y */ float y
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.points);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].y = y;
					break;
				}
			}
		}
		
		this.points = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Y for Point Key<br/>
	 */
	void setPointY (
			/**/ String key,
			/**/ float y
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.points);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].y = y;
				break;
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Y for Point Key<br/>
	 */
	float getPointY (
			/**/ String key
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.points);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].y;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Use Manual 'Points' Property
	 */	
	void setUsePoints( /**Use Manual 'Points'*/ boolean usePoints){*
		this.usePoints = usePoints;
	*}

	/**
	 * Gets Use Manual 'Points' Property
	 */	
	boolean isUsePoints() {*
		return this.usePoints;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartLabel
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartLabel extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Label Property
	 */	
	void setLabel( /**Label*/ String label){*
		this.label = label;
	*}

	/**
	 * Gets Label Property
	 */	
	String getLabel() {*
		return this.label;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartPoint
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartPoint extends org.scn.community.shared.DataComponent {





	/**
	 * Sets Use Manual 'X' Property
	 */	
	void setUseX( /**Use Manual 'X'*/ boolean useX){*
		this.useX = useX;
	*}

	/**
	 * Gets Use Manual 'X' Property
	 */	
	boolean isUseX() {*
		return this.useX;
	*}

	/**
	 * Sets Use Manual 'Y' Property
	 */	
	void setUseY( /**Use Manual 'Y'*/ boolean useY){*
		this.useY = useY;
	*}

	/**
	 * Gets Use Manual 'Y' Property
	 */	
	boolean isUseY() {*
		return this.useY;
	*}

	/**
	 * Sets X Property
	 */	
	void setX( /**X*/ float x){*
		this.x = x;
	*}

	/**
	 * Gets X Property
	 */	
	float getX() {*
		return this.x;
	*}

	/**
	 * Sets Y Property
	 */	
	void setY( /**Y*/ float y){*
		this.y = y;
	*}

	/**
	 * Gets Y Property
	 */	
	float getY() {*
		return this.y;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for NavigationList
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.NavigationList extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}



	/**
	 * Sets Expanded Property
	 */	
	void setExpanded( /**Expanded*/ boolean expanded){*
		this.expanded = expanded;
	*}

	/**
	 * Gets Expanded Property
	 */	
	boolean isExpanded() {*
		return this.expanded;
	*}

	/**
	 * Gets Item Selected Key Property
	 */	
	String getItemSelectedKey() {*
		return this.itemSelectedKey;
	*}

	/** Adds a root element containing key [String], expanded [boolean], hasExpander [boolean], icon [String].

 	<example>
	You want to add 2 root elements
	<code>
	NAVIGATIONLIST.addItem(key [String], expanded [boolean], hasExpander [boolean], icon [String]);<br>
	NAVIGATIONLIST.addItem(key [String], expanded [boolean], hasExpander [boolean], icon [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addItem (
			/**Unique Property Key*/String key, 
			/**Expanded*/boolean expanded, 
			/**Has Expander*/boolean hasExpander, 
			/**Icon*/String icon
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			expanded:expanded, 
			hasExpander:hasExpander, 
			icon:icon
			};

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	NAVIGATIONLIST.removeItem(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeItem (
			String key
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	NAVIGATIONLIST.insertItem(index [int], key [String], expanded [boolean], hasExpander [boolean], icon [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertItem (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Expanded*/boolean expanded, 
			/**Has Expander*/boolean hasExpander, 
			/**Icon*/String icon
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}
		
		var elementsJson = JSON.parse(this.items);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			expanded:expanded, 
			hasExpander:hasExpander, 
			icon:icon
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.items = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Item<br/>
	 */
	void updateItem (
			/**Unique Property Key*/String key, 
			/**Expanded*/boolean expanded, 
			/**Has Expander*/boolean hasExpander, 
			/**Icon*/String icon
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			expanded:expanded, 
			hasExpander:hasExpander, 
			icon:icon
		};

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getItemAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Items As JSON String
	 */	
	String getItemsAsJSON() {*
		var jsonObject = JSON.parse(this.items);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Items
	 */	
	String cleanAllItems() {*
		this.items = "[]";
	*}
	
	/**
	 * Sets the Expanded for Item keys<br/>
	 */
	void setItemExpandeds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].expanded = true;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Expanded for Item Key<br/>
	 */
	void setItemExpanded (
			/**/ String key,
			/**/ boolean expanded
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].expanded = expanded;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Expanded of Item keys<br/>
	 */
	void cleanAllItemExpandeds (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
		}
		
		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Expanded for Item Key<br/>
	 */
	String getItemExpanded (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].expanded;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Expanded keys<br/>
	 */
	org.scn.community.shared.KeyArray getItemExpandedKeysArray (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.items);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].expanded == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the HasExpander for Item keys<br/>
	 */
	void setItemHasExpanders (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].hasExpander = true;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the HasExpander for Item Key<br/>
	 */
	void setItemHasExpander (
			/**/ String key,
			/**/ boolean hasExpander
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].hasExpander = hasExpander;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all HasExpander of Item keys<br/>
	 */
	void cleanAllItemHasExpanders (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
		}
		
		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of HasExpander for Item Key<br/>
	 */
	String getItemHasExpander (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].hasExpander;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the HasExpander keys<br/>
	 */
	org.scn.community.shared.KeyArray getItemHasExpanderKeysArray (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.items);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].hasExpander == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Icon for Item keys<br/>
	 */
	void setItemIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Item Key<br/>
	 */
	void setItemIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Item Key<br/>
	 */
	String getItemIcon (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}





	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'Items' Property
	 */	
	void setUseItems( /**Use Manual 'Items'*/ boolean useItems){*
		this.useItems = useItems;
	*}

	/**
	 * Gets Use Manual 'Items' Property
	 */	
	boolean isUseItems() {*
		return this.useItems;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for NavigationListItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.NavigationListItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Expanded Property
	 */	
	void setExpanded( /**Expanded*/ boolean expanded){*
		this.expanded = expanded;
	*}

	/**
	 * Gets Expanded Property
	 */	
	boolean isExpanded() {*
		return this.expanded;
	*}

	/**
	 * Sets Has Expander Property
	 */	
	void setHasExpander( /**Has Expander*/ boolean hasExpander){*
		this.hasExpander = hasExpander;
	*}

	/**
	 * Gets Has Expander Property
	 */	
	boolean isHasExpander() {*
		return this.hasExpander;
	*}

	/**
	 * Sets Icon Property
	 */	
	void setIcon( /**Icon*/ String icon){*
		this.icon = icon;
	*}

	/**
	 * Gets Icon Property
	 */	
	String getIcon() {*
		return this.icon;
	*}



	/**
	 * Gets Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Use Manual 'Icon' Property
	 */	
	void setUseIcon( /**Use Manual 'Icon'*/ boolean useIcon){*
		this.useIcon = useIcon;
	*}

	/**
	 * Gets Use Manual 'Icon' Property
	 */	
	boolean isUseIcon() {*
		return this.useIcon;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for PlanningCalendar
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.PlanningCalendar extends org.scn.community.shared.DataComponent {

	/**
	 * Gets Appointment Selected Key Property
	 */	
	String getAppointmentSelectedKey() {*
		return this.appointmentSelectedKey;
	*}

	/** Adds a root element containing key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	PLANNINGCALENDAR.addAppointment(key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	PLANNINGCALENDAR.addAppointment(key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addAppointment (
			/**Unique Appointment Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if(ntype == undefined) { ntype = "";}
		if(icon == undefined) { icon = "";}
		if(selected == undefined) { selected = false;}
		if(tentative == undefined) { tentative = false;}
		
		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
			};

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PLANNINGCALENDAR.removeAppointment(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeAppointment (
			String key
			) {*

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PLANNINGCALENDAR.insertAppointment(index [int], key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void insertAppointment (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Appointment Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}
		
		var elementsJson = JSON.parse(this.appointments);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.appointments = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Appointment<br/>
	 */
	void updateAppointment (
			/**Unique Appointment Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getAppointmentAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Appointments As JSON String
	 */	
	String getAppointmentsAsJSON() {*
		var jsonObject = JSON.parse(this.appointments);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Appointments
	 */	
	String cleanAllAppointments() {*
		this.appointments = "[]";
	*}
	
	/**
	 * Sets the RowKey for Appointment keys<br/>
	 */
	void setAppointmentRowKeys (
			/**/ String keys,
			/**/ String separator,
	        /* RowKey */ String rowKey
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].rowKey = rowKey;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the RowKey for Appointment Key<br/>
	 */
	void setAppointmentRowKey (
			/**/ String key,
			/**/ String rowKey
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].rowKey = rowKey;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of RowKey for Appointment Key<br/>
	 */
	String getAppointmentRowKey (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].rowKey;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Start for Appointment keys<br/>
	 */
	void setAppointmentStarts (
			/**/ String keys,
			/**/ String separator,
	        /* Start */ String start
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].start = start;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Start for Appointment Key<br/>
	 */
	void setAppointmentStart (
			/**/ String key,
			/**/ String start
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].start = start;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Start for Appointment Key<br/>
	 */
	String getAppointmentStart (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].start;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the End for Appointment keys<br/>
	 */
	void setAppointmentEnds (
			/**/ String keys,
			/**/ String separator,
	        /* End */ String end
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].end = end;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the End for Appointment Key<br/>
	 */
	void setAppointmentEnd (
			/**/ String key,
			/**/ String end
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].end = end;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of End for Appointment Key<br/>
	 */
	String getAppointmentEnd (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].end;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Text for Appointment keys<br/>
	 */
	void setAppointmentTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Appointment Key<br/>
	 */
	void setAppointmentText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Appointment Key<br/>
	 */
	String getAppointmentText (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Title for Appointment keys<br/>
	 */
	void setAppointmentTitles (
			/**/ String keys,
			/**/ String separator,
	        /* Title */ String title
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].title = title;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Title for Appointment Key<br/>
	 */
	void setAppointmentTitle (
			/**/ String key,
			/**/ String title
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].title = title;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Title for Appointment Key<br/>
	 */
	String getAppointmentTitle (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].title;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Ntype for Appointment keys<br/>
	 */
	void setAppointmentNtypes (
			/**/ String keys,
			/**/ String separator,
	        /* Ntype */ String ntype
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].ntype = ntype;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Ntype for Appointment Key<br/>
	 */
	void setAppointmentNtype (
			/**/ String key,
			/**/ String ntype
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].ntype = ntype;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Ntype for Appointment Key<br/>
	 */
	String getAppointmentNtype (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].ntype;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Appointment keys<br/>
	 */
	void setAppointmentIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Appointment Key<br/>
	 */
	void setAppointmentIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Appointment Key<br/>
	 */
	String getAppointmentIcon (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Selected for Appointment keys<br/>
	 */
	void setAppointmentSelecteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].selected = true;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Selected for Appointment Key<br/>
	 */
	void setAppointmentSelected (
			/**/ String key,
			/**/ boolean selected
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].selected = selected;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Selected of Appointment keys<br/>
	 */
	void cleanAllAppointmentSelecteds (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Selected for Appointment Key<br/>
	 */
	String getAppointmentSelected (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].selected;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Selected keys<br/>
	 */
	org.scn.community.shared.KeyArray getAppointmentSelectedKeysArray (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.appointments);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].selected == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Tentative for Appointment keys<br/>
	 */
	void setAppointmentTentatives (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].tentative = true;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Tentative for Appointment Key<br/>
	 */
	void setAppointmentTentative (
			/**/ String key,
			/**/ boolean tentative
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].tentative = tentative;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Tentative of Appointment keys<br/>
	 */
	void cleanAllAppointmentTentatives (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Tentative for Appointment Key<br/>
	 */
	String getAppointmentTentative (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].tentative;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Tentative keys<br/>
	 */
	org.scn.community.shared.KeyArray getAppointmentTentativeKeysArray (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.appointments);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].tentative == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}



	/**
	 * Clean All Appointments from the Array.
	 */	
	void cleanAllAppointments (){*
		this.cleanAllAppointments = true;

		var elementsArray = [];
		this.appointments = JSON.stringify(elementsArray);
	*}

	/**
	 * Remove All Appointments from the Array.
	 * You can use also <code>cleanAllElements()</code>
	 */	
	@Visibility(deprecated)
	void removeAllAppointments (){*
		this.cleanAllAppointments = true;

		var elementsArray = [];
		this.appointments = JSON.stringify(elementsArray);
	*}

	/**
	 * Clean All Interval Headers from the Array.
	 */	
	void cleanAllIntervalHeaders (){*
		this.cleanAllIntervalHeaders = true;

		var elementsArray = [];
		this.intervalHeaders = JSON.stringify(elementsArray);
	*}

	/**
	 * Remove All Interval Headers from the Array.
	 * You can use also <code>cleanAllElements()</code>
	 */	
	@Visibility(deprecated)
	void removeAllIntervalHeaders (){*
		this.cleanAllIntervalHeaders = true;

		var elementsArray = [];
		this.intervalHeaders = JSON.stringify(elementsArray);
	*}

	/**
	 * Clean All Rows from the Array.
	 */	
	void cleanAllRows (){*
		this.cleanAllRows = true;

		var elementsArray = [];
		this.rows = JSON.stringify(elementsArray);
	*}

	/**
	 * Remove All Rows from the Array.
	 * You can use also <code>cleanAllElements()</code>
	 */	
	@Visibility(deprecated)
	void removeAllRows (){*
		this.cleanAllRows = true;

		var elementsArray = [];
		this.rows = JSON.stringify(elementsArray);
	*}











	/** Adds a root element containing key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	PLANNINGCALENDAR.addIntervalHeader(key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	PLANNINGCALENDAR.addIntervalHeader(key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addIntervalHeader (
			/**Unique Header Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if(ntype == undefined) { ntype = "";}
		if(icon == undefined) { icon = "";}
		if(selected == undefined) { selected = false;}
		if(tentative == undefined) { tentative = false;}
		
		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
			};

		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			this.intervalHeaders = "[]";
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PLANNINGCALENDAR.removeIntervalHeader(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeIntervalHeader (
			String key
			) {*

		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			this.intervalHeaders = "[]";
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PLANNINGCALENDAR.insertIntervalHeader(index [int], key [String], rowKey [String], start [String], end [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void insertIntervalHeader (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Header Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			this.intervalHeaders = "[]";
		}
		
		var elementsJson = JSON.parse(this.intervalHeaders);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.intervalHeaders = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given IntervalHeader<br/>
	 */
	void updateIntervalHeader (
			/**Unique Header Key*/String key, 
			/**Unique Row Key*/String rowKey, 
			/**Start Date/Time*/String start, 
			/**End Date/Time*/String end, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			this.intervalHeaders = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			rowKey:rowKey, 
			start:start, 
			end:end, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getIntervalHeaderAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			this.intervalHeaders = "[]";
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets IntervalHeaders As JSON String
	 */	
	String getIntervalHeadersAsJSON() {*
		var jsonObject = JSON.parse(this.intervalHeaders);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All IntervalHeaders
	 */	
	String cleanAllIntervalHeaders() {*
		this.intervalHeaders = "[]";
	*}
	
	/**
	 * Sets the RowKey for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderRowKeys (
			/**/ String keys,
			/**/ String separator,
	        /* RowKey */ String rowKey
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].rowKey = rowKey;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the RowKey for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderRowKey (
			/**/ String key,
			/**/ String rowKey
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].rowKey = rowKey;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of RowKey for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderRowKey (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].rowKey;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Start for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderStarts (
			/**/ String keys,
			/**/ String separator,
	        /* Start */ String start
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].start = start;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Start for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderStart (
			/**/ String key,
			/**/ String start
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].start = start;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Start for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderStart (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].start;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the End for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderEnds (
			/**/ String keys,
			/**/ String separator,
	        /* End */ String end
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].end = end;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the End for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderEnd (
			/**/ String key,
			/**/ String end
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].end = end;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of End for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderEnd (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].end;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Text for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderText (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Title for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderTitles (
			/**/ String keys,
			/**/ String separator,
	        /* Title */ String title
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].title = title;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Title for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderTitle (
			/**/ String key,
			/**/ String title
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].title = title;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Title for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderTitle (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].title;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Ntype for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderNtypes (
			/**/ String keys,
			/**/ String separator,
	        /* Ntype */ String ntype
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].ntype = ntype;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Ntype for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderNtype (
			/**/ String key,
			/**/ String ntype
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].ntype = ntype;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Ntype for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderNtype (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].ntype;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderIcon (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Selected for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderSelecteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].selected = true;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Selected for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderSelected (
			/**/ String key,
			/**/ boolean selected
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].selected = selected;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Selected of IntervalHeader keys<br/>
	 */
	void cleanAllIntervalHeaderSelecteds (
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Selected for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderSelected (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].selected;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Selected keys<br/>
	 */
	org.scn.community.shared.KeyArray getIntervalHeaderSelectedKeysArray (
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.intervalHeaders);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].selected == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Tentative for IntervalHeader keys<br/>
	 */
	void setIntervalHeaderTentatives (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].tentative = true;
					break;
				}
			}
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Tentative for IntervalHeader Key<br/>
	 */
	void setIntervalHeaderTentative (
			/**/ String key,
			/**/ boolean tentative
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].tentative = tentative;
				break;
			}
		}

		this.intervalHeaders = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Tentative of IntervalHeader keys<br/>
	 */
	void cleanAllIntervalHeaderTentatives (
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
		}
		
		this.intervalHeaders = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Tentative for IntervalHeader Key<br/>
	 */
	String getIntervalHeaderTentative (
			/**/ String key
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.intervalHeaders);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].tentative;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Tentative keys<br/>
	 */
	org.scn.community.shared.KeyArray getIntervalHeaderTentativeKeysArray (
			) 
	{*
		if (this.intervalHeaders === undefined || this.intervalHeaders === "" || this.intervalHeaders === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.intervalHeaders);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].tentative == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}





	/**
	 * Sets No Data Text Property
	 */	
	void setNoDataText( /**No Data Text*/ String noDataText){*
		this.noDataText = noDataText;
	*}

	/**
	 * Gets No Data Text Property
	 */	
	String getNoDataText() {*
		return this.noDataText;
	*}











	/**
	 * Gets Row Selection Changed Key Property
	 */	
	String getRowSelectionChangedKey() {*
		return this.rowSelectionChangedKey;
	*}

	/** Adds a root element containing key [String], text [String], title [String], icon [String], selected [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	PLANNINGCALENDAR.addRow(key [String], text [String], title [String], icon [String], selected [boolean]);<br>
	PLANNINGCALENDAR.addRow(key [String], text [String], title [String], icon [String], selected [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addRow (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected
			) {*

		if(icon == undefined) { icon = "";}
		if(selected == undefined) { selected = false;}
		
		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			icon:icon, 
			selected:selected
			};

		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			this.rows = "[]";
		}

		var elementsJson = JSON.parse(this.rows);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.rows = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PLANNINGCALENDAR.removeRow(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeRow (
			String key
			) {*

		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			this.rows = "[]";
		}

		var elementsJson = JSON.parse(this.rows);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PLANNINGCALENDAR.insertRow(index [int], key [String], text [String], title [String], icon [String], selected [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void insertRow (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected
			) {*

		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			this.rows = "[]";
		}
		
		var elementsJson = JSON.parse(this.rows);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			icon:icon, 
			selected:selected
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.rows = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Row<br/>
	 */
	void updateRow (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			this.rows = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			icon:icon, 
			selected:selected
		};

		var elementsJson = JSON.parse(this.rows);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getRowAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			this.rows = "[]";
		}

		var elementsJson = JSON.parse(this.rows);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Rows As JSON String
	 */	
	String getRowsAsJSON() {*
		var jsonObject = JSON.parse(this.rows);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Rows
	 */	
	String cleanAllRows() {*
		this.rows = "[]";
	*}
	
	/**
	 * Sets the Text for Row keys<br/>
	 */
	void setRowTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.rows);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.rows = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Row Key<br/>
	 */
	void setRowText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Row Key<br/>
	 */
	String getRowText (
			/**/ String key
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Title for Row keys<br/>
	 */
	void setRowTitles (
			/**/ String keys,
			/**/ String separator,
	        /* Title */ String title
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.rows);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].title = title;
					break;
				}
			}
		}
		
		this.rows = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Title for Row Key<br/>
	 */
	void setRowTitle (
			/**/ String key,
			/**/ String title
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].title = title;
				break;
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Title for Row Key<br/>
	 */
	String getRowTitle (
			/**/ String key
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].title;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Row keys<br/>
	 */
	void setRowIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.rows);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.rows = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Row Key<br/>
	 */
	void setRowIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Row Key<br/>
	 */
	String getRowIcon (
			/**/ String key
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Selected for Row keys<br/>
	 */
	void setRowSelecteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.rows);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].selected = true;
					break;
				}
			}
		}
		
		this.rows = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Selected for Row Key<br/>
	 */
	void setRowSelected (
			/**/ String key,
			/**/ boolean selected
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].selected = selected;
				break;
			}
		}

		this.rows = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Selected of Row keys<br/>
	 */
	void cleanAllRowSelecteds (
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
		}
		
		this.rows = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Selected for Row Key<br/>
	 */
	String getRowSelected (
			/**/ String key
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.rows);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].selected;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Selected keys<br/>
	 */
	org.scn.community.shared.KeyArray getRowSelectedKeysArray (
			) 
	{*
		if (this.rows === undefined || this.rows === "" || this.rows === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.rows);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].selected == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}



	/**
	 * Sets Show Interval Headers Property
	 */	
	void setShowIntervalHeaders( /**Show Interval Headers*/ boolean showIntervalHeaders){*
		this.showIntervalHeaders = showIntervalHeaders;
	*}

	/**
	 * Gets Show Interval Headers Property
	 */	
	boolean isShowIntervalHeaders() {*
		return this.showIntervalHeaders;
	*}

	/**
	 * Sets Show Row Headers Property
	 */	
	void setShowRowHeaders( /**Show Row Headers*/ boolean showRowHeaders){*
		this.showRowHeaders = showRowHeaders;
	*}

	/**
	 * Gets Show Row Headers Property
	 */	
	boolean isShowRowHeaders() {*
		return this.showRowHeaders;
	*}

	/**
	 * Sets Start Date Property
	 */	
	void setStartDate( /**Start Date*/ String startDate){*
		this.startDate = startDate;
	*}

	/**
	 * Gets Start Date Property
	 */	
	String getStartDate() {*
		return this.startDate;
	*}















	/**
	 * Sets View Type Property by String
	 */	
	void setViewKeyByString( /**View Type*/ String viewKey){*
		this.viewKey = viewKey;
	*}

	/**
	 * Gets View Type Property as String
	 */	
	String getViewKeyAsString() {*
		return this.viewKey;
	*}
	
	/**
	 * Sets View Type Property by Choice Option
	 */	
	void setViewKey( /**View Type*/ org_scn_community_shared_Enumfield viewKey){*
		this.viewKey = viewKey;
	*}
	
	/**
	 * Gets View Type Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getViewKey() {*
		return this.viewKey;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for PlanningCalendarRow
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.PlanningCalendarRow extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	PLANNINGCALENDARROW.addAppointment(key [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	PLANNINGCALENDARROW.addAppointment(key [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addAppointment (
			/**Unique Appointment Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if(ntype == undefined) { ntype = "";}
		if(icon == undefined) { icon = "";}
		if(selected == undefined) { selected = false;}
		if(tentative == undefined) { tentative = false;}
		
		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
			};

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PLANNINGCALENDARROW.removeAppointment(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeAppointment (
			String key
			) {*

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PLANNINGCALENDARROW.insertAppointment(index [int], key [String], text [String], title [String], ntype [String], icon [String], selected [boolean], tentative [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void insertAppointment (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Appointment Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) {*

		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}
		
		var elementsJson = JSON.parse(this.appointments);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.appointments = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Appointment<br/>
	 */
	void updateAppointment (
			/**Unique Appointment Key*/String key, 
			/**Text*/String text, 
			/**Title*/String title, 
			/**Type*/optional String ntype, 
			/**Icon*/optional String icon, 
			/**Selected*/optional boolean selected, 
			/**Tentative*/optional boolean tentative
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			text:text, 
			title:title, 
			ntype:ntype, 
			icon:icon, 
			selected:selected, 
			tentative:tentative
		};

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getAppointmentAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			this.appointments = "[]";
		}

		var elementsJson = JSON.parse(this.appointments);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Appointments As JSON String
	 */	
	String getAppointmentsAsJSON() {*
		var jsonObject = JSON.parse(this.appointments);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Appointments
	 */	
	String cleanAllAppointments() {*
		this.appointments = "[]";
	*}
	
	/**
	 * Sets the Text for Appointment keys<br/>
	 */
	void setAppointmentTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Appointment Key<br/>
	 */
	void setAppointmentText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Appointment Key<br/>
	 */
	String getAppointmentText (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Title for Appointment keys<br/>
	 */
	void setAppointmentTitles (
			/**/ String keys,
			/**/ String separator,
	        /* Title */ String title
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].title = title;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Title for Appointment Key<br/>
	 */
	void setAppointmentTitle (
			/**/ String key,
			/**/ String title
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].title = title;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Title for Appointment Key<br/>
	 */
	String getAppointmentTitle (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].title;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Ntype for Appointment keys<br/>
	 */
	void setAppointmentNtypes (
			/**/ String keys,
			/**/ String separator,
	        /* Ntype */ String ntype
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].ntype = ntype;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Ntype for Appointment Key<br/>
	 */
	void setAppointmentNtype (
			/**/ String key,
			/**/ String ntype
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].ntype = ntype;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Ntype for Appointment Key<br/>
	 */
	String getAppointmentNtype (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].ntype;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Appointment keys<br/>
	 */
	void setAppointmentIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Appointment Key<br/>
	 */
	void setAppointmentIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Appointment Key<br/>
	 */
	String getAppointmentIcon (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Selected for Appointment keys<br/>
	 */
	void setAppointmentSelecteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].selected = true;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Selected for Appointment Key<br/>
	 */
	void setAppointmentSelected (
			/**/ String key,
			/**/ boolean selected
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].selected = selected;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Selected of Appointment keys<br/>
	 */
	void cleanAllAppointmentSelecteds (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Selected for Appointment Key<br/>
	 */
	String getAppointmentSelected (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].selected;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Selected keys<br/>
	 */
	org.scn.community.shared.KeyArray getAppointmentSelectedKeysArray (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.appointments);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].selected == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Tentative for Appointment keys<br/>
	 */
	void setAppointmentTentatives (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].tentative = true;
					break;
				}
			}
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Tentative for Appointment Key<br/>
	 */
	void setAppointmentTentative (
			/**/ String key,
			/**/ boolean tentative
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].tentative = tentative;
				break;
			}
		}

		this.appointments = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Tentative of Appointment keys<br/>
	 */
	void cleanAllAppointmentTentatives (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].tentative = false;
		}
		
		this.appointments = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Tentative for Appointment Key<br/>
	 */
	String getAppointmentTentative (
			/**/ String key
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.appointments);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].tentative;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Tentative keys<br/>
	 */
	org.scn.community.shared.KeyArray getAppointmentTentativeKeysArray (
			) 
	{*
		if (this.appointments === undefined || this.appointments === "" || this.appointments === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.appointments);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].tentative == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}





	/**
	 * Sets Icon Property
	 */	
	void setIcon( /**Icon*/ String icon){*
		this.icon = icon;
	*}

	/**
	 * Gets Icon Property
	 */	
	String getIcon() {*
		return this.icon;
	*}

	/**
	 * Sets Key Property
	 */	
	void setKey( /**Key*/ String key){*
		this.key = key;
	*}

	/**
	 * Gets Key Property
	 */	
	String getKey() {*
		return this.key;
	*}

	/**
	 * Sets Non Working Days Property
	 */	
	void setNonWorkingDays( /**Non Working Days*/ String nonWorkingDays){*
		this.nonWorkingDays = nonWorkingDays;
	*}

	/**
	 * Gets Non Working Days Property
	 */	
	String getNonWorkingDays() {*
		return this.nonWorkingDays;
	*}

	/**
	 * Sets Non Working Hours Property
	 */	
	void setNonWorkingHours( /**Non Working Hours*/ String nonWorkingHours){*
		this.nonWorkingHours = nonWorkingHours;
	*}

	/**
	 * Gets Non Working Hours Property
	 */	
	String getNonWorkingHours() {*
		return this.nonWorkingHours;
	*}

	/**
	 * Sets Selected Property
	 */	
	void setSelected( /**Selected*/ boolean selected){*
		this.selected = selected;
	*}

	/**
	 * Gets Selected Property
	 */	
	boolean isSelected() {*
		return this.selected;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Title Property
	 */	
	void setTitle( /**Title*/ String title){*
		this.title = title;
	*}

	/**
	 * Gets Title Property
	 */	
	String getTitle() {*
		return this.title;
	*}

	/**
	 * Sets Use Manual 'Appointments' Property
	 */	
	void setUseAppointments( /**Use Manual 'Appointments'*/ boolean useAppointments){*
		this.useAppointments = useAppointments;
	*}

	/**
	 * Gets Use Manual 'Appointments' Property
	 */	
	boolean isUseAppointments() {*
		return this.useAppointments;
	*}

	/**
	 * Sets Use Manual 'Icon' Property
	 */	
	void setUseIcon( /**Use Manual 'Icon'*/ boolean useIcon){*
		this.useIcon = useIcon;
	*}

	/**
	 * Gets Use Manual 'Icon' Property
	 */	
	boolean isUseIcon() {*
		return this.useIcon;
	*}

	/**
	 * Sets Use Manual 'Non Working Days' Property
	 */	
	void setUseNonWorkingDays( /**Use Manual 'Non Working Days'*/ boolean useNonWorkingDays){*
		this.useNonWorkingDays = useNonWorkingDays;
	*}

	/**
	 * Gets Use Manual 'Non Working Days' Property
	 */	
	boolean isUseNonWorkingDays() {*
		return this.useNonWorkingDays;
	*}

	/**
	 * Sets Use Manual 'Non Working Hours' Property
	 */	
	void setUseNonWorkingHours( /**Use Manual 'Non Working Hours'*/ boolean useNonWorkingHours){*
		this.useNonWorkingHours = useNonWorkingHours;
	*}

	/**
	 * Gets Use Manual 'Non Working Hours' Property
	 */	
	boolean isUseNonWorkingHours() {*
		return this.useNonWorkingHours;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for ProcessFlow
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.ProcessFlow extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], drawData [String], zoomLevel [String].

 	<example>
	You want to add 2 root elements
	<code>
	PROCESSFLOW.addConnection(key [String], drawData [String], zoomLevel [String]);<br>
	PROCESSFLOW.addConnection(key [String], drawData [String], zoomLevel [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addConnection (
			/**Unique Property Key*/String key, 
			/**Draw Data [Array]*/String drawData, 
			/**Zoom Level*/String zoomLevel
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			drawData:drawData, 
			zoomLevel:zoomLevel
			};

		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			this.connections = "[]";
		}

		var elementsJson = JSON.parse(this.connections);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.connections = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PROCESSFLOW.removeConnection(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeConnection (
			String key
			) {*

		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			this.connections = "[]";
		}

		var elementsJson = JSON.parse(this.connections);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.connections = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PROCESSFLOW.insertConnection(index [int], key [String], drawData [String], zoomLevel [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertConnection (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Draw Data [Array]*/String drawData, 
			/**Zoom Level*/String zoomLevel
			) {*

		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			this.connections = "[]";
		}
		
		var elementsJson = JSON.parse(this.connections);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			drawData:drawData, 
			zoomLevel:zoomLevel
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.connections = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Connection<br/>
	 */
	void updateConnection (
			/**Unique Property Key*/String key, 
			/**Draw Data [Array]*/String drawData, 
			/**Zoom Level*/String zoomLevel
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			this.connections = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			drawData:drawData, 
			zoomLevel:zoomLevel
		};

		var elementsJson = JSON.parse(this.connections);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.connections = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getConnectionAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			this.connections = "[]";
		}

		var elementsJson = JSON.parse(this.connections);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Connections As JSON String
	 */	
	String getConnectionsAsJSON() {*
		var jsonObject = JSON.parse(this.connections);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Connections
	 */	
	String cleanAllConnections() {*
		this.connections = "[]";
	*}
	
	/**
	 * Sets the DrawData for Connection keys<br/>
	 */
	void setConnectionDrawDatas (
			/**/ String keys,
			/**/ String separator,
	        /* DrawData */ String drawData
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.connections);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].drawData = drawData;
					break;
				}
			}
		}
		
		this.connections = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the DrawData for Connection Key<br/>
	 */
	void setConnectionDrawData (
			/**/ String key,
			/**/ String drawData
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.connections);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].drawData = drawData;
				break;
			}
		}

		this.connections = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of DrawData for Connection Key<br/>
	 */
	String getConnectionDrawData (
			/**/ String key
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.connections);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].drawData;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the ZoomLevel for Connection keys<br/>
	 */
	void setConnectionZoomLevels (
			/**/ String keys,
			/**/ String separator,
	        /* ZoomLevel */ String zoomLevel
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.connections);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].zoomLevel = zoomLevel;
					break;
				}
			}
		}
		
		this.connections = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ZoomLevel for Connection Key<br/>
	 */
	void setConnectionZoomLevel (
			/**/ String key,
			/**/ String zoomLevel
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.connections);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].zoomLevel = zoomLevel;
				break;
			}
		}

		this.connections = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ZoomLevel for Connection Key<br/>
	 */
	String getConnectionZoomLevel (
			/**/ String key
			) 
	{*
		if (this.connections === undefined || this.connections === "" || this.connections === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.connections);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].zoomLevel;
				break;
			}
		}
		
		return value;
	*}









	/**
	 * Sets Folded Corners Property
	 */	
	void setFoldedCorners( /**Folded Corners*/ boolean foldedCorners){*
		this.foldedCorners = foldedCorners;
	*}

	/**
	 * Gets Folded Corners Property
	 */	
	boolean isFoldedCorners() {*
		return this.foldedCorners;
	*}

	/**
	 * Gets Header Pressed Key Property
	 */	
	String getHeaderPressedKey() {*
		return this.headerPressedKey;
	*}

	/** Adds a root element containing key [String], iconSrc [String], laneId [String], position [int], state [String], text [String], zoomLevel [String].

 	<example>
	You want to add 2 root elements
	<code>
	PROCESSFLOW.addLane(key [String], iconSrc [String], laneId [String], position [int], state [String], text [String], zoomLevel [String]);<br>
	PROCESSFLOW.addLane(key [String], iconSrc [String], laneId [String], position [int], state [String], text [String], zoomLevel [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addLane (
			/**Unique Property Key*/String key, 
			/**Icon Src*/String iconSrc, 
			/**Lane Id*/String laneId, 
			/**Position*/int position, 
			/**State*/String state, 
			/**Text*/String text, 
			/**Zoom Level*/String zoomLevel
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			iconSrc:iconSrc, 
			laneId:laneId, 
			position:position, 
			state:state, 
			text:text, 
			zoomLevel:zoomLevel
			};

		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			this.lanes = "[]";
		}

		var elementsJson = JSON.parse(this.lanes);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PROCESSFLOW.removeLane(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeLane (
			String key
			) {*

		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			this.lanes = "[]";
		}

		var elementsJson = JSON.parse(this.lanes);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PROCESSFLOW.insertLane(index [int], key [String], iconSrc [String], laneId [String], position [int], state [String], text [String], zoomLevel [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertLane (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Icon Src*/String iconSrc, 
			/**Lane Id*/String laneId, 
			/**Position*/int position, 
			/**State*/String state, 
			/**Text*/String text, 
			/**Zoom Level*/String zoomLevel
			) {*

		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			this.lanes = "[]";
		}
		
		var elementsJson = JSON.parse(this.lanes);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			iconSrc:iconSrc, 
			laneId:laneId, 
			position:position, 
			state:state, 
			text:text, 
			zoomLevel:zoomLevel
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.lanes = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Lane<br/>
	 */
	void updateLane (
			/**Unique Property Key*/String key, 
			/**Icon Src*/String iconSrc, 
			/**Lane Id*/String laneId, 
			/**Position*/int position, 
			/**State*/String state, 
			/**Text*/String text, 
			/**Zoom Level*/String zoomLevel
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			this.lanes = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			iconSrc:iconSrc, 
			laneId:laneId, 
			position:position, 
			state:state, 
			text:text, 
			zoomLevel:zoomLevel
		};

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLaneAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			this.lanes = "[]";
		}

		var elementsJson = JSON.parse(this.lanes);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Lanes As JSON String
	 */	
	String getLanesAsJSON() {*
		var jsonObject = JSON.parse(this.lanes);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Lanes
	 */	
	String cleanAllLanes() {*
		this.lanes = "[]";
	*}
	
	/**
	 * Sets the IconSrc for Lane keys<br/>
	 */
	void setLaneIconSrcs (
			/**/ String keys,
			/**/ String separator,
	        /* IconSrc */ String iconSrc
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].iconSrc = iconSrc;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the IconSrc for Lane Key<br/>
	 */
	void setLaneIconSrc (
			/**/ String key,
			/**/ String iconSrc
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].iconSrc = iconSrc;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of IconSrc for Lane Key<br/>
	 */
	String getLaneIconSrc (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].iconSrc;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the LaneId for Lane keys<br/>
	 */
	void setLaneLaneIds (
			/**/ String keys,
			/**/ String separator,
	        /* LaneId */ String laneId
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].laneId = laneId;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the LaneId for Lane Key<br/>
	 */
	void setLaneLaneId (
			/**/ String key,
			/**/ String laneId
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].laneId = laneId;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of LaneId for Lane Key<br/>
	 */
	String getLaneLaneId (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].laneId;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Position for Lane keys<br/>
	 */
	void setLanePositions (
			/**/ String keys,
			/**/ String separator,
	        /* Position */ int position
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].position = position;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Position for Lane Key<br/>
	 */
	void setLanePosition (
			/**/ String key,
			/**/ int position
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].position = position;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Position for Lane Key<br/>
	 */
	int getLanePosition (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].position;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the State for Lane keys<br/>
	 */
	void setLaneStates (
			/**/ String keys,
			/**/ String separator,
	        /* State */ String state
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].state = state;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the State for Lane Key<br/>
	 */
	void setLaneState (
			/**/ String key,
			/**/ String state
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].state = state;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of State for Lane Key<br/>
	 */
	String getLaneState (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].state;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Text for Lane keys<br/>
	 */
	void setLaneTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Lane Key<br/>
	 */
	void setLaneText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Lane Key<br/>
	 */
	String getLaneText (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the ZoomLevel for Lane keys<br/>
	 */
	void setLaneZoomLevels (
			/**/ String keys,
			/**/ String separator,
	        /* ZoomLevel */ String zoomLevel
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].zoomLevel = zoomLevel;
					break;
				}
			}
		}
		
		this.lanes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ZoomLevel for Lane Key<br/>
	 */
	void setLaneZoomLevel (
			/**/ String key,
			/**/ String zoomLevel
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].zoomLevel = zoomLevel;
				break;
			}
		}

		this.lanes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ZoomLevel for Lane Key<br/>
	 */
	String getLaneZoomLevel (
			/**/ String key
			) 
	{*
		if (this.lanes === undefined || this.lanes === "" || this.lanes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lanes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].zoomLevel;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Gets Node Pressed Key Property
	 */	
	String getNodePressedKey() {*
		return this.nodePressedKey;
	*}

	/** Adds a root element containing key [String], children [String], focused [boolean], highlighted [boolean], isTitleClickable [boolean], laneId [String], nodeId [String], state [String], stateText [String], tag [String], texts [String], title [String], titleAbbreviation [String].

 	<example>
	You want to add 2 root elements
	<code>
	PROCESSFLOW.addNode(key [String], children [String], focused [boolean], highlighted [boolean], isTitleClickable [boolean], laneId [String], nodeId [String], state [String], stateText [String], tag [String], texts [String], title [String], titleAbbreviation [String]);<br>
	PROCESSFLOW.addNode(key [String], children [String], focused [boolean], highlighted [boolean], isTitleClickable [boolean], laneId [String], nodeId [String], state [String], stateText [String], tag [String], texts [String], title [String], titleAbbreviation [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addNode (
			/**Unique Property Key*/String key, 
			/**Children [Array]*/String children, 
			/**Focused*/boolean focused, 
			/**Highlighted*/boolean highlighted, 
			/**Is Title Clickable*/boolean isTitleClickable, 
			/**Lane Id*/String laneId, 
			/**Node Id*/String nodeId, 
			/**State*/String state, 
			/**State Text*/String stateText, 
			/**Tag*/String tag, 
			/**Texts [Array]*/String texts, 
			/**Title*/String title, 
			/**Title Abbreviation*/String titleAbbreviation
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			children:children, 
			focused:focused, 
			highlighted:highlighted, 
			isTitleClickable:isTitleClickable, 
			laneId:laneId, 
			nodeId:nodeId, 
			state:state, 
			stateText:stateText, 
			tag:tag, 
			texts:texts, 
			title:title, 
			titleAbbreviation:titleAbbreviation
			};

		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			this.nodes = "[]";
		}

		var elementsJson = JSON.parse(this.nodes);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	PROCESSFLOW.removeNode(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeNode (
			String key
			) {*

		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			this.nodes = "[]";
		}

		var elementsJson = JSON.parse(this.nodes);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	PROCESSFLOW.insertNode(index [int], key [String], children [String], focused [boolean], highlighted [boolean], isTitleClickable [boolean], laneId [String], nodeId [String], state [String], stateText [String], tag [String], texts [String], title [String], titleAbbreviation [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertNode (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Children [Array]*/String children, 
			/**Focused*/boolean focused, 
			/**Highlighted*/boolean highlighted, 
			/**Is Title Clickable*/boolean isTitleClickable, 
			/**Lane Id*/String laneId, 
			/**Node Id*/String nodeId, 
			/**State*/String state, 
			/**State Text*/String stateText, 
			/**Tag*/String tag, 
			/**Texts [Array]*/String texts, 
			/**Title*/String title, 
			/**Title Abbreviation*/String titleAbbreviation
			) {*

		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			this.nodes = "[]";
		}
		
		var elementsJson = JSON.parse(this.nodes);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			children:children, 
			focused:focused, 
			highlighted:highlighted, 
			isTitleClickable:isTitleClickable, 
			laneId:laneId, 
			nodeId:nodeId, 
			state:state, 
			stateText:stateText, 
			tag:tag, 
			texts:texts, 
			title:title, 
			titleAbbreviation:titleAbbreviation
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.nodes = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Node<br/>
	 */
	void updateNode (
			/**Unique Property Key*/String key, 
			/**Children [Array]*/String children, 
			/**Focused*/boolean focused, 
			/**Highlighted*/boolean highlighted, 
			/**Is Title Clickable*/boolean isTitleClickable, 
			/**Lane Id*/String laneId, 
			/**Node Id*/String nodeId, 
			/**State*/String state, 
			/**State Text*/String stateText, 
			/**Tag*/String tag, 
			/**Texts [Array]*/String texts, 
			/**Title*/String title, 
			/**Title Abbreviation*/String titleAbbreviation
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			this.nodes = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			children:children, 
			focused:focused, 
			highlighted:highlighted, 
			isTitleClickable:isTitleClickable, 
			laneId:laneId, 
			nodeId:nodeId, 
			state:state, 
			stateText:stateText, 
			tag:tag, 
			texts:texts, 
			title:title, 
			titleAbbreviation:titleAbbreviation
		};

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getNodeAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			this.nodes = "[]";
		}

		var elementsJson = JSON.parse(this.nodes);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Nodes As JSON String
	 */	
	String getNodesAsJSON() {*
		var jsonObject = JSON.parse(this.nodes);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Nodes
	 */	
	String cleanAllNodes() {*
		this.nodes = "[]";
	*}
	
	/**
	 * Sets the Children for Node keys<br/>
	 */
	void setNodeChildrens (
			/**/ String keys,
			/**/ String separator,
	        /* Children */ String children
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].children = children;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Children for Node Key<br/>
	 */
	void setNodeChildren (
			/**/ String key,
			/**/ String children
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].children = children;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Children for Node Key<br/>
	 */
	String getNodeChildren (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].children;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Focused for Node keys<br/>
	 */
	void setNodeFocuseds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].focused = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].focused = true;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Focused for Node Key<br/>
	 */
	void setNodeFocused (
			/**/ String key,
			/**/ boolean focused
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].focused = focused;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Focused of Node keys<br/>
	 */
	void cleanAllNodeFocuseds (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].focused = false;
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Focused for Node Key<br/>
	 */
	String getNodeFocused (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].focused;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Focused keys<br/>
	 */
	org.scn.community.shared.KeyArray getNodeFocusedKeysArray (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.nodes);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].focused == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Highlighted for Node keys<br/>
	 */
	void setNodeHighlighteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].highlighted = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].highlighted = true;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Highlighted for Node Key<br/>
	 */
	void setNodeHighlighted (
			/**/ String key,
			/**/ boolean highlighted
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].highlighted = highlighted;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Highlighted of Node keys<br/>
	 */
	void cleanAllNodeHighlighteds (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].highlighted = false;
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Highlighted for Node Key<br/>
	 */
	String getNodeHighlighted (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].highlighted;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Highlighted keys<br/>
	 */
	org.scn.community.shared.KeyArray getNodeHighlightedKeysArray (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.nodes);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].highlighted == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the IsTitleClickable for Node keys<br/>
	 */
	void setNodeIsTitleClickables (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].isTitleClickable = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].isTitleClickable = true;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the IsTitleClickable for Node Key<br/>
	 */
	void setNodeIsTitleClickable (
			/**/ String key,
			/**/ boolean isTitleClickable
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].isTitleClickable = isTitleClickable;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all IsTitleClickable of Node keys<br/>
	 */
	void cleanAllNodeIsTitleClickables (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].isTitleClickable = false;
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of IsTitleClickable for Node Key<br/>
	 */
	String getNodeIsTitleClickable (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].isTitleClickable;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the IsTitleClickable keys<br/>
	 */
	org.scn.community.shared.KeyArray getNodeIsTitleClickableKeysArray (
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.nodes);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].isTitleClickable == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the LaneId for Node keys<br/>
	 */
	void setNodeLaneIds (
			/**/ String keys,
			/**/ String separator,
	        /* LaneId */ String laneId
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].laneId = laneId;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the LaneId for Node Key<br/>
	 */
	void setNodeLaneId (
			/**/ String key,
			/**/ String laneId
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].laneId = laneId;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of LaneId for Node Key<br/>
	 */
	String getNodeLaneId (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].laneId;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the NodeId for Node keys<br/>
	 */
	void setNodeNodeIds (
			/**/ String keys,
			/**/ String separator,
	        /* NodeId */ String nodeId
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].nodeId = nodeId;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the NodeId for Node Key<br/>
	 */
	void setNodeNodeId (
			/**/ String key,
			/**/ String nodeId
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].nodeId = nodeId;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of NodeId for Node Key<br/>
	 */
	String getNodeNodeId (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].nodeId;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the State for Node keys<br/>
	 */
	void setNodeStates (
			/**/ String keys,
			/**/ String separator,
	        /* State */ String state
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].state = state;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the State for Node Key<br/>
	 */
	void setNodeState (
			/**/ String key,
			/**/ String state
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].state = state;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of State for Node Key<br/>
	 */
	String getNodeState (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].state;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the StateText for Node keys<br/>
	 */
	void setNodeStateTexts (
			/**/ String keys,
			/**/ String separator,
	        /* StateText */ String stateText
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].stateText = stateText;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the StateText for Node Key<br/>
	 */
	void setNodeStateText (
			/**/ String key,
			/**/ String stateText
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].stateText = stateText;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of StateText for Node Key<br/>
	 */
	String getNodeStateText (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].stateText;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Tag for Node keys<br/>
	 */
	void setNodeTags (
			/**/ String keys,
			/**/ String separator,
	        /* Tag */ String tag
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].tag = tag;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Tag for Node Key<br/>
	 */
	void setNodeTag (
			/**/ String key,
			/**/ String tag
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].tag = tag;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Tag for Node Key<br/>
	 */
	String getNodeTag (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].tag;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Texts for Node keys<br/>
	 */
	void setNodeTextss (
			/**/ String keys,
			/**/ String separator,
	        /* Texts */ String texts
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].texts = texts;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Texts for Node Key<br/>
	 */
	void setNodeTexts (
			/**/ String key,
			/**/ String texts
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].texts = texts;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Texts for Node Key<br/>
	 */
	String getNodeTexts (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].texts;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Title for Node keys<br/>
	 */
	void setNodeTitles (
			/**/ String keys,
			/**/ String separator,
	        /* Title */ String title
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].title = title;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Title for Node Key<br/>
	 */
	void setNodeTitle (
			/**/ String key,
			/**/ String title
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].title = title;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Title for Node Key<br/>
	 */
	String getNodeTitle (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].title;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the TitleAbbreviation for Node keys<br/>
	 */
	void setNodeTitleAbbreviations (
			/**/ String keys,
			/**/ String separator,
	        /* TitleAbbreviation */ String titleAbbreviation
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].titleAbbreviation = titleAbbreviation;
					break;
				}
			}
		}
		
		this.nodes = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the TitleAbbreviation for Node Key<br/>
	 */
	void setNodeTitleAbbreviation (
			/**/ String key,
			/**/ String titleAbbreviation
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].titleAbbreviation = titleAbbreviation;
				break;
			}
		}

		this.nodes = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of TitleAbbreviation for Node Key<br/>
	 */
	String getNodeTitleAbbreviation (
			/**/ String key
			) 
	{*
		if (this.nodes === undefined || this.nodes === "" || this.nodes === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.nodes);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].titleAbbreviation;
				break;
			}
		}
		
		return value;
	*}





	/**
	 * Gets  Errored Key Property
	 */	
	String getOnErroredKey() {*
		return this.onErroredKey;
	*}





	/**
	 * Sets Scrollable Property
	 */	
	void setScrollable( /**Scrollable*/ boolean scrollable){*
		this.scrollable = scrollable;
	*}

	/**
	 * Gets Scrollable Property
	 */	
	boolean isScrollable() {*
		return this.scrollable;
	*}

	/**
	 * Sets Use Manual 'Connections' Property
	 */	
	void setUseConnections( /**Use Manual 'Connections'*/ boolean useConnections){*
		this.useConnections = useConnections;
	*}

	/**
	 * Gets Use Manual 'Connections' Property
	 */	
	boolean isUseConnections() {*
		return this.useConnections;
	*}

	/**
	 * Sets Use Manual 'Lanes' Property
	 */	
	void setUseLanes( /**Use Manual 'Lanes'*/ boolean useLanes){*
		this.useLanes = useLanes;
	*}

	/**
	 * Gets Use Manual 'Lanes' Property
	 */	
	boolean isUseLanes() {*
		return this.useLanes;
	*}

	/**
	 * Sets Use Manual 'Nodes' Property
	 */	
	void setUseNodes( /**Use Manual 'Nodes'*/ boolean useNodes){*
		this.useNodes = useNodes;
	*}

	/**
	 * Gets Use Manual 'Nodes' Property
	 */	
	boolean isUseNodes() {*
		return this.useNodes;
	*}

	/**
	 * Sets Wheel Zoomable Property
	 */	
	void setWheelZoomable( /**Wheel Zoomable*/ boolean wheelZoomable){*
		this.wheelZoomable = wheelZoomable;
	*}

	/**
	 * Gets Wheel Zoomable Property
	 */	
	boolean isWheelZoomable() {*
		return this.wheelZoomable;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for ProcessFlowConnection
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.ProcessFlowConnection extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Draw Data Property as StringArray
	 */	
	void setDrawData( /**Draw Data*/ StringArray drawData){*
		this.drawData = drawData;
	*}
	
	/** Gets Draw Data Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	PROCESSFLOWCONNECTION.getDrawData();<br>
	</code>
	</example>
	 */
	StringArray getDrawData () {*		
		var elementsJson = JSON.parse(this.drawData);
		return elementsJson;
	*}

	/**
	 * Sets Use Manual 'Draw Data' Property
	 */	
	void setUseDrawData( /**Use Manual 'Draw Data'*/ boolean useDrawData){*
		this.useDrawData = useDrawData;
	*}

	/**
	 * Gets Use Manual 'Draw Data' Property
	 */	
	boolean isUseDrawData() {*
		return this.useDrawData;
	*}

	/**
	 * Sets Zoom Level Property by String
	 */	
	void setZoomLevelByString( /**Zoom Level*/ String zoomLevel){*
		this.zoomLevel = zoomLevel;
	*}

	/**
	 * Gets Zoom Level Property as String
	 */	
	String getZoomLevelAsString() {*
		return this.zoomLevel;
	*}
	
	/**
	 * Sets Zoom Level Property by Choice Option
	 */	
	void setZoomLevel( /**Zoom Level*/ org_scn_community_shared_ProcessFlowZoomLevelEnumfield zoomLevel){*
		this.zoomLevel = zoomLevel;
	*}
	
	/**
	 * Gets Zoom Level Property as Choice Option
	 */	
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield getZoomLevel() {*
		return this.zoomLevel;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for ProcessFlowLaneHeader
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.ProcessFlowLaneHeader extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Icon Src Property
	 */	
	void setIconSrc( /**Icon Src*/ String iconSrc){*
		this.iconSrc = iconSrc;
	*}

	/**
	 * Gets Icon Src Property
	 */	
	String getIconSrc() {*
		return this.iconSrc;
	*}

	/**
	 * Sets Lane Id Property
	 */	
	void setLaneId( /**Lane Id*/ String laneId){*
		this.laneId = laneId;
	*}

	/**
	 * Gets Lane Id Property
	 */	
	String getLaneId() {*
		return this.laneId;
	*}



	/**
	 * Sets Position Property
	 */	
	void setPosition( /**Position*/ int position){*
		this.position = position;
	*}

	/**
	 * Gets Position Property
	 */	
	int getPosition() {*
		return this.position;
	*}

	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Sets State Property
	 */	
	void setState( /**State*/ String state){*
		this.state = state;
	*}

	/**
	 * Gets State Property
	 */	
	String getState() {*
		return this.state;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Use Manual 'Icon Src' Property
	 */	
	void setUseIconSrc( /**Use Manual 'Icon Src'*/ boolean useIconSrc){*
		this.useIconSrc = useIconSrc;
	*}

	/**
	 * Gets Use Manual 'Icon Src' Property
	 */	
	boolean isUseIconSrc() {*
		return this.useIconSrc;
	*}

	/**
	 * Sets Use Manual 'Position' Property
	 */	
	void setUsePosition( /**Use Manual 'Position'*/ boolean usePosition){*
		this.usePosition = usePosition;
	*}

	/**
	 * Gets Use Manual 'Position' Property
	 */	
	boolean isUsePosition() {*
		return this.usePosition;
	*}

	/**
	 * Sets Zoom Level Property by String
	 */	
	void setZoomLevelByString( /**Zoom Level*/ String zoomLevel){*
		this.zoomLevel = zoomLevel;
	*}

	/**
	 * Gets Zoom Level Property as String
	 */	
	String getZoomLevelAsString() {*
		return this.zoomLevel;
	*}
	
	/**
	 * Sets Zoom Level Property by Choice Option
	 */	
	void setZoomLevel( /**Zoom Level*/ org_scn_community_shared_ProcessFlowZoomLevelEnumfield zoomLevel){*
		this.zoomLevel = zoomLevel;
	*}
	
	/**
	 * Gets Zoom Level Property as Choice Option
	 */	
	org_scn_community_shared_ProcessFlowZoomLevelEnumfield getZoomLevel() {*
		return this.zoomLevel;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for ProcessFlowNode
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.ProcessFlowNode extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Children Property as StringArray
	 */	
	void setChildren( /**Children*/ StringArray children){*
		this.children = children;
	*}
	
	/** Gets Children Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	PROCESSFLOWNODE.getChildren();<br>
	</code>
	</example>
	 */
	StringArray getChildren () {*		
		var elementsJson = JSON.parse(this.children);
		return elementsJson;
	*}

	/**
	 * Sets Focused Property
	 */	
	void setFocused( /**Focused*/ boolean focused){*
		this.focused = focused;
	*}

	/**
	 * Gets Focused Property
	 */	
	boolean isFocused() {*
		return this.focused;
	*}

	/**
	 * Sets Highlighted Property
	 */	
	void setHighlighted( /**Highlighted*/ boolean highlighted){*
		this.highlighted = highlighted;
	*}

	/**
	 * Gets Highlighted Property
	 */	
	boolean isHighlighted() {*
		return this.highlighted;
	*}

	/**
	 * Sets Is Title Clickable Property
	 */	
	void setIsTitleClickable( /**Is Title Clickable*/ boolean isTitleClickable){*
		this.isTitleClickable = isTitleClickable;
	*}

	/**
	 * Gets Is Title Clickable Property
	 */	
	boolean isIsTitleClickable() {*
		return this.isTitleClickable;
	*}

	/**
	 * Sets Lane Id Property
	 */	
	void setLaneId( /**Lane Id*/ String laneId){*
		this.laneId = laneId;
	*}

	/**
	 * Gets Lane Id Property
	 */	
	String getLaneId() {*
		return this.laneId;
	*}

	/**
	 * Sets Node Id Property
	 */	
	void setNodeId( /**Node Id*/ String nodeId){*
		this.nodeId = nodeId;
	*}

	/**
	 * Gets Node Id Property
	 */	
	String getNodeId() {*
		return this.nodeId;
	*}



	/**
	 * Gets Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Sets State Property by String
	 */	
	void setStateByString( /**State*/ String state){*
		this.state = state;
	*}

	/**
	 * Gets State Property as String
	 */	
	String getStateAsString() {*
		return this.state;
	*}
	
	/**
	 * Sets State Property by Choice Option
	 */	
	void setState( /**State*/ org_scn_community_shared_ProcessFlowNodeStateEnumfield state){*
		this.state = state;
	*}
	
	/**
	 * Gets State Property as Choice Option
	 */	
	org_scn_community_shared_ProcessFlowNodeStateEnumfield getState() {*
		return this.state;
	*}

	/**
	 * Sets State Text Property
	 */	
	void setStateText( /**State Text*/ String stateText){*
		this.stateText = stateText;
	*}

	/**
	 * Gets State Text Property
	 */	
	String getStateText() {*
		return this.stateText;
	*}

	/**
	 * Sets Tag Property
	 */	
	void setTag( /**Tag*/ String tag){*
		this.tag = tag;
	*}

	/**
	 * Gets Tag Property
	 */	
	String getTag() {*
		return this.tag;
	*}

	/**
	 * Sets Texts Property as StringArray
	 */	
	void setTexts( /**Texts*/ StringArray texts){*
		this.texts = texts;
	*}
	
	/** Gets Texts Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	PROCESSFLOWNODE.getTexts();<br>
	</code>
	</example>
	 */
	StringArray getTexts () {*		
		var elementsJson = JSON.parse(this.texts);
		return elementsJson;
	*}

	/**
	 * Sets Title Property
	 */	
	void setTitle( /**Title*/ String title){*
		this.title = title;
	*}

	/**
	 * Gets Title Property
	 */	
	String getTitle() {*
		return this.title;
	*}

	/**
	 * Sets Title Abbreviation Property
	 */	
	void setTitleAbbreviation( /**Title Abbreviation*/ String titleAbbreviation){*
		this.titleAbbreviation = titleAbbreviation;
	*}

	/**
	 * Gets Title Abbreviation Property
	 */	
	String getTitleAbbreviation() {*
		return this.titleAbbreviation;
	*}

	/**
	 * Sets Use Manual 'Children' Property
	 */	
	void setUseChildren( /**Use Manual 'Children'*/ boolean useChildren){*
		this.useChildren = useChildren;
	*}

	/**
	 * Gets Use Manual 'Children' Property
	 */	
	boolean isUseChildren() {*
		return this.useChildren;
	*}

	/**
	 * Sets Use Manual 'Texts' Property
	 */	
	void setUseTexts( /**Use Manual 'Texts'*/ boolean useTexts){*
		this.useTexts = useTexts;
	*}

	/**
	 * Gets Use Manual 'Texts' Property
	 */	
	boolean isUseTexts() {*
		return this.useTexts;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for RadioButton
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.RadioButton extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Active Handling Property
	 */	
	void setActiveHandling( /**Active Handling*/ boolean activeHandling){*
		this.activeHandling = activeHandling;
	*}

	/**
	 * Gets Active Handling Property
	 */	
	boolean isActiveHandling() {*
		return this.activeHandling;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/**
	 * Sets Editable Property
	 */	
	void setEditable( /**Editable*/ boolean editable){*
		this.editable = editable;
	*}

	/**
	 * Gets Editable Property
	 */	
	boolean isEditable() {*
		return this.editable;
	*}

	/**
	 * Sets Enabled Property
	 */	
	void setEnabled( /**Enabled*/ boolean enabled){*
		this.enabled = enabled;
	*}

	/**
	 * Gets Enabled Property
	 */	
	boolean isEnabled() {*
		return this.enabled;
	*}

	/**
	 * Sets Group Name Property
	 */	
	void setGroupName( /**Group Name*/ String groupName){*
		this.groupName = groupName;
	*}

	/**
	 * Gets Group Name Property
	 */	
	String getGroupName() {*
		return this.groupName;
	*}



	/**
	 * Sets Selected Property
	 */	
	void setSelected( /**Selected*/ boolean selected){*
		this.selected = selected;
	*}

	/**
	 * Gets Selected Property
	 */	
	boolean isSelected() {*
		return this.selected;
	*}

	/**
	 * Gets Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Text Property
	 */	
	void setText( /**Text*/ String text){*
		this.text = text;
	*}

	/**
	 * Gets Text Property
	 */	
	String getText() {*
		return this.text;
	*}

	/**
	 * Sets Text Align Property by String
	 */	
	void setTextAlignByString( /**Text Align*/ String textAlign){*
		this.textAlign = textAlign;
	*}

	/**
	 * Gets Text Align Property as String
	 */	
	String getTextAlignAsString() {*
		return this.textAlign;
	*}
	
	/**
	 * Sets Text Align Property by Choice Option
	 */	
	void setTextAlign( /**Text Align*/ org_scn_community_shared_TextAlignEnumfield textAlign){*
		this.textAlign = textAlign;
	*}
	
	/**
	 * Gets Text Align Property as Choice Option
	 */	
	org_scn_community_shared_TextAlignEnumfield getTextAlign() {*
		return this.textAlign;
	*}

	/**
	 * Sets Text Direction Property by String
	 */	
	void setTextDirectionByString( /**Text Direction*/ String textDirection){*
		this.textDirection = textDirection;
	*}

	/**
	 * Gets Text Direction Property as String
	 */	
	String getTextDirectionAsString() {*
		return this.textDirection;
	*}
	
	/**
	 * Sets Text Direction Property by Choice Option
	 */	
	void setTextDirection( /**Text Direction*/ org_scn_community_shared_TextDirectionEnumfield textDirection){*
		this.textDirection = textDirection;
	*}
	
	/**
	 * Gets Text Direction Property as Choice Option
	 */	
	org_scn_community_shared_TextDirectionEnumfield getTextDirection() {*
		return this.textDirection;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Value State Property by String
	 */	
	void setValueStateByString( /**Value State*/ String valueState){*
		this.valueState = valueState;
	*}

	/**
	 * Gets Value State Property as String
	 */	
	String getValueStateAsString() {*
		return this.valueState;
	*}
	
	/**
	 * Sets Value State Property by Choice Option
	 */	
	void setValueState( /**Value State*/ org_scn_community_shared_ValueStateEnumfield valueState){*
		this.valueState = valueState;
	*}
	
	/**
	 * Gets Value State Property as Choice Option
	 */	
	org_scn_community_shared_ValueStateEnumfield getValueState() {*
		return this.valueState;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for RadioButtonGroup
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.RadioButtonGroup extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], activeHandling [boolean], contentWidth [int], editable [boolean], enabled [boolean], groupName [String], selected [boolean], text [String], textAlign [String], textDirection [String], valueState [String].

 	<example>
	You want to add 2 root elements
	<code>
	RADIOBUTTONGROUP.addButton(key [String], activeHandling [boolean], contentWidth [int], editable [boolean], enabled [boolean], groupName [String], selected [boolean], text [String], textAlign [String], textDirection [String], valueState [String]);<br>
	RADIOBUTTONGROUP.addButton(key [String], activeHandling [boolean], contentWidth [int], editable [boolean], enabled [boolean], groupName [String], selected [boolean], text [String], textAlign [String], textDirection [String], valueState [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addButton (
			/**Unique Property Key*/String key, 
			/**Active Handling*/boolean activeHandling, 
			/**Content Width*/int contentWidth, 
			/**Editable*/boolean editable, 
			/**Enabled*/boolean enabled, 
			/**Group Name*/String groupName, 
			/**Selected*/boolean selected, 
			/**Text*/String text, 
			/**Text Align*/String textAlign, 
			/**Text Direction*/String textDirection, 
			/**Value State*/String valueState
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			activeHandling:activeHandling, 
			contentWidth:contentWidth, 
			editable:editable, 
			enabled:enabled, 
			groupName:groupName, 
			selected:selected, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			valueState:valueState
			};

		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			this.buttons = "[]";
		}

		var elementsJson = JSON.parse(this.buttons);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	RADIOBUTTONGROUP.removeButton(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeButton (
			String key
			) {*

		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			this.buttons = "[]";
		}

		var elementsJson = JSON.parse(this.buttons);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	RADIOBUTTONGROUP.insertButton(index [int], key [String], activeHandling [boolean], contentWidth [int], editable [boolean], enabled [boolean], groupName [String], selected [boolean], text [String], textAlign [String], textDirection [String], valueState [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertButton (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Active Handling*/boolean activeHandling, 
			/**Content Width*/int contentWidth, 
			/**Editable*/boolean editable, 
			/**Enabled*/boolean enabled, 
			/**Group Name*/String groupName, 
			/**Selected*/boolean selected, 
			/**Text*/String text, 
			/**Text Align*/String textAlign, 
			/**Text Direction*/String textDirection, 
			/**Value State*/String valueState
			) {*

		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			this.buttons = "[]";
		}
		
		var elementsJson = JSON.parse(this.buttons);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			activeHandling:activeHandling, 
			contentWidth:contentWidth, 
			editable:editable, 
			enabled:enabled, 
			groupName:groupName, 
			selected:selected, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			valueState:valueState
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.buttons = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Button<br/>
	 */
	void updateButton (
			/**Unique Property Key*/String key, 
			/**Active Handling*/boolean activeHandling, 
			/**Content Width*/int contentWidth, 
			/**Editable*/boolean editable, 
			/**Enabled*/boolean enabled, 
			/**Group Name*/String groupName, 
			/**Selected*/boolean selected, 
			/**Text*/String text, 
			/**Text Align*/String textAlign, 
			/**Text Direction*/String textDirection, 
			/**Value State*/String valueState
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			this.buttons = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			activeHandling:activeHandling, 
			contentWidth:contentWidth, 
			editable:editable, 
			enabled:enabled, 
			groupName:groupName, 
			selected:selected, 
			text:text, 
			textAlign:textAlign, 
			textDirection:textDirection, 
			valueState:valueState
		};

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getButtonAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			this.buttons = "[]";
		}

		var elementsJson = JSON.parse(this.buttons);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Buttons As JSON String
	 */	
	String getButtonsAsJSON() {*
		var jsonObject = JSON.parse(this.buttons);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Buttons
	 */	
	String cleanAllButtons() {*
		this.buttons = "[]";
	*}
	
	/**
	 * Sets the ActiveHandling for Button keys<br/>
	 */
	void setButtonActiveHandlings (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].activeHandling = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].activeHandling = true;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ActiveHandling for Button Key<br/>
	 */
	void setButtonActiveHandling (
			/**/ String key,
			/**/ boolean activeHandling
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].activeHandling = activeHandling;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all ActiveHandling of Button keys<br/>
	 */
	void cleanAllButtonActiveHandlings (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].activeHandling = false;
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ActiveHandling for Button Key<br/>
	 */
	String getButtonActiveHandling (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].activeHandling;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the ActiveHandling keys<br/>
	 */
	org.scn.community.shared.KeyArray getButtonActiveHandlingKeysArray (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.buttons);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].activeHandling == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the ContentWidth for Button keys<br/>
	 */
	void setButtonContentWidths (
			/**/ String keys,
			/**/ String separator,
	        /* ContentWidth */ int contentWidth
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].contentWidth = contentWidth;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ContentWidth for Button Key<br/>
	 */
	void setButtonContentWidth (
			/**/ String key,
			/**/ int contentWidth
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].contentWidth = contentWidth;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ContentWidth for Button Key<br/>
	 */
	int getButtonContentWidth (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].contentWidth;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Editable for Button keys<br/>
	 */
	void setButtonEditables (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].editable = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].editable = true;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Editable for Button Key<br/>
	 */
	void setButtonEditable (
			/**/ String key,
			/**/ boolean editable
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].editable = editable;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Editable of Button keys<br/>
	 */
	void cleanAllButtonEditables (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].editable = false;
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Editable for Button Key<br/>
	 */
	String getButtonEditable (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].editable;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Editable keys<br/>
	 */
	org.scn.community.shared.KeyArray getButtonEditableKeysArray (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.buttons);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].editable == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Enabled for Button keys<br/>
	 */
	void setButtonEnableds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].enabled = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].enabled = true;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Enabled for Button Key<br/>
	 */
	void setButtonEnabled (
			/**/ String key,
			/**/ boolean enabled
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].enabled = enabled;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Enabled of Button keys<br/>
	 */
	void cleanAllButtonEnableds (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].enabled = false;
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Enabled for Button Key<br/>
	 */
	String getButtonEnabled (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].enabled;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Enabled keys<br/>
	 */
	org.scn.community.shared.KeyArray getButtonEnabledKeysArray (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.buttons);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].enabled == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the GroupName for Button keys<br/>
	 */
	void setButtonGroupNames (
			/**/ String keys,
			/**/ String separator,
	        /* GroupName */ String groupName
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].groupName = groupName;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the GroupName for Button Key<br/>
	 */
	void setButtonGroupName (
			/**/ String key,
			/**/ String groupName
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].groupName = groupName;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of GroupName for Button Key<br/>
	 */
	String getButtonGroupName (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].groupName;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Selected for Button keys<br/>
	 */
	void setButtonSelecteds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].selected = true;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Selected for Button Key<br/>
	 */
	void setButtonSelected (
			/**/ String key,
			/**/ boolean selected
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].selected = selected;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Selected of Button keys<br/>
	 */
	void cleanAllButtonSelecteds (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].selected = false;
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Selected for Button Key<br/>
	 */
	String getButtonSelected (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].selected;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Selected keys<br/>
	 */
	org.scn.community.shared.KeyArray getButtonSelectedKeysArray (
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.buttons);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].selected == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Text for Button keys<br/>
	 */
	void setButtonTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Button Key<br/>
	 */
	void setButtonText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Button Key<br/>
	 */
	String getButtonText (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the TextAlign for Button keys<br/>
	 */
	void setButtonTextAligns (
			/**/ String keys,
			/**/ String separator,
	        /* TextAlign */ String textAlign
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].textAlign = textAlign;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the TextAlign for Button Key<br/>
	 */
	void setButtonTextAlign (
			/**/ String key,
			/**/ String textAlign
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].textAlign = textAlign;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of TextAlign for Button Key<br/>
	 */
	String getButtonTextAlign (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].textAlign;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the TextDirection for Button keys<br/>
	 */
	void setButtonTextDirections (
			/**/ String keys,
			/**/ String separator,
	        /* TextDirection */ String textDirection
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].textDirection = textDirection;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the TextDirection for Button Key<br/>
	 */
	void setButtonTextDirection (
			/**/ String key,
			/**/ String textDirection
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].textDirection = textDirection;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of TextDirection for Button Key<br/>
	 */
	String getButtonTextDirection (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].textDirection;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the ValueState for Button keys<br/>
	 */
	void setButtonValueStates (
			/**/ String keys,
			/**/ String separator,
	        /* ValueState */ String valueState
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].valueState = valueState;
					break;
				}
			}
		}
		
		this.buttons = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ValueState for Button Key<br/>
	 */
	void setButtonValueState (
			/**/ String key,
			/**/ String valueState
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].valueState = valueState;
				break;
			}
		}

		this.buttons = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ValueState for Button Key<br/>
	 */
	String getButtonValueState (
			/**/ String key
			) 
	{*
		if (this.buttons === undefined || this.buttons === "" || this.buttons === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.buttons);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].valueState;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Columns Property
	 */	
	void setColumns( /**Columns*/ int columns){*
		this.columns = columns;
	*}

	/**
	 * Gets Columns Property
	 */	
	int getColumns() {*
		return this.columns;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}



	/**
	 * Sets Editable Property
	 */	
	void setEditable( /**Editable*/ boolean editable){*
		this.editable = editable;
	*}

	/**
	 * Gets Editable Property
	 */	
	boolean isEditable() {*
		return this.editable;
	*}

	/**
	 * Sets Enabled Property
	 */	
	void setEnabled( /**Enabled*/ boolean enabled){*
		this.enabled = enabled;
	*}

	/**
	 * Gets Enabled Property
	 */	
	boolean isEnabled() {*
		return this.enabled;
	*}



	/**
	 * Sets Selected Index Property
	 */	
	void setSelectedIndex( /**Selected Index*/ int selectedIndex){*
		this.selectedIndex = selectedIndex;
	*}

	/**
	 * Gets Selected Index Property
	 */	
	int getSelectedIndex() {*
		return this.selectedIndex;
	*}

	/**
	 * Gets Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Text Direction Property by String
	 */	
	void setTextDirectionByString( /**Text Direction*/ String textDirection){*
		this.textDirection = textDirection;
	*}

	/**
	 * Gets Text Direction Property as String
	 */	
	String getTextDirectionAsString() {*
		return this.textDirection;
	*}
	
	/**
	 * Sets Text Direction Property by Choice Option
	 */	
	void setTextDirection( /**Text Direction*/ org_scn_community_shared_TextDirectionEnumfield textDirection){*
		this.textDirection = textDirection;
	*}
	
	/**
	 * Gets Text Direction Property as Choice Option
	 */	
	org_scn_community_shared_TextDirectionEnumfield getTextDirection() {*
		return this.textDirection;
	*}

	/**
	 * Sets Use Manual 'Buttons' Property
	 */	
	void setUseButtons( /**Use Manual 'Buttons'*/ boolean useButtons){*
		this.useButtons = useButtons;
	*}

	/**
	 * Gets Use Manual 'Buttons' Property
	 */	
	boolean isUseButtons() {*
		return this.useButtons;
	*}

	/**
	 * Sets Use Manual 'Columns' Property
	 */	
	void setUseColumns( /**Use Manual 'Columns'*/ boolean useColumns){*
		this.useColumns = useColumns;
	*}

	/**
	 * Gets Use Manual 'Columns' Property
	 */	
	boolean isUseColumns() {*
		return this.useColumns;
	*}

	/**
	 * Sets Use Manual 'Content Width' Property
	 */	
	void setUseContentWidth( /**Use Manual 'Content Width'*/ boolean useContentWidth){*
		this.useContentWidth = useContentWidth;
	*}

	/**
	 * Gets Use Manual 'Content Width' Property
	 */	
	boolean isUseContentWidth() {*
		return this.useContentWidth;
	*}

	/**
	 * Sets Use Manual 'Selected Index' Property
	 */	
	void setUseSelectedIndex( /**Use Manual 'Selected Index'*/ boolean useSelectedIndex){*
		this.useSelectedIndex = useSelectedIndex;
	*}

	/**
	 * Gets Use Manual 'Selected Index' Property
	 */	
	boolean isUseSelectedIndex() {*
		return this.useSelectedIndex;
	*}

	/**
	 * Sets Value State Property by String
	 */	
	void setValueStateByString( /**Value State*/ String valueState){*
		this.valueState = valueState;
	*}

	/**
	 * Gets Value State Property as String
	 */	
	String getValueStateAsString() {*
		return this.valueState;
	*}
	
	/**
	 * Sets Value State Property by Choice Option
	 */	
	void setValueState( /**Value State*/ org_scn_community_shared_ValueStateEnumfield valueState){*
		this.valueState = valueState;
	*}
	
	/**
	 * Gets Value State Property as Choice Option
	 */	
	org_scn_community_shared_ValueStateEnumfield getValueState() {*
		return this.valueState;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for SideNavigation
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.SideNavigation extends org.scn.community.shared.DataComponent {









	/**
	 * Sets Expanded Property
	 */	
	void setExpanded( /**Expanded*/ boolean expanded){*
		this.expanded = expanded;
	*}

	/**
	 * Gets Expanded Property
	 */	
	boolean isExpanded() {*
		return this.expanded;
	*}

	/** Adds an element containing parentKey [String], key [String], text [String], icon [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	SIDENAVIGATION.addItems(parentKey [String], key [String], text [String], icon [String]);<br>
	SIDENAVIGATION.addItems(parentKey [String], key [String], text [String], icon [String]);
	</code>
	</example>
	 */
	void addItems (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**Text*/String text, 
			/**Icon*/optional String icon
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		if(icon == undefined) { icon = "";}
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			text:text, 
			icon:icon 
			};
	
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			this.fixedItem = "[]";
		}
		
		var elementsJson = JSON.parse(this.fixedItem);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/** Adds a root element containing key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	SIDENAVIGATION.addFixedItem(key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean]);<br>
	SIDENAVIGATION.addFixedItem(key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addFixedItem (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Icon*/optional String icon, 
			/**Expanded*/optional boolean expanded, 
			/**Has Expander*/optional boolean hasExpander
			) {*		
		
		if(icon == undefined) { icon = "";}
		if(expanded == undefined) { expanded = false;}
		if(hasExpander == undefined) { hasExpander = false;}
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			text:text, 
			icon:icon, 
			expanded:expanded, 
			hasExpander:hasExpander 
			};
	
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			this.fixedItem = "[]";
		}
		
		var elementsJson = JSON.parse(this.fixedItem);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	SIDENAVIGATION.removeItems(String key);<br>
	</code>
	</example>
	 */
	void removeItems (
			String key
			) {*		
		
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			this.fixedItem = "[]";
		}
		
		var elementsJson = JSON.parse(this.fixedItem);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	SIDENAVIGATION.removeFixedItem(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeFixedItem (
			String key
			) {*		
		
		this.removeItems(key);
	*}

	/**
	 * Gets FixedItems As JSON String
	 */	
	String getFixedItemsAsJSON() {*
		var jsonObject = JSON.parse(this.fixedItem);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All FixedItems
	 */	
	String cleanAllFixedItems() {*
		this.fixedItem = "[]";
	*}
	/**
	 * Sets the Text for FixedItem keys<br/>
	 */
	void setFixedItemTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for FixedItem Key<br/>
	 */
	void setFixedItemText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for FixedItem Key<br/>
	 */
	String getFixedItemText (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for FixedItem keys<br/>
	 */
	void setFixedItemIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for FixedItem Key<br/>
	 */
	void setFixedItemIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for FixedItem Key<br/>
	 */
	String getFixedItemIcon (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Expanded for FixedItem keys<br/>
	 */
	void setFixedItemExpandeds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].expanded = true;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Expanded for FixedItem Key<br/>
	 */
	void setFixedItemExpanded (
			/**/ String key,
			/**/ boolean expanded
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].expanded = expanded;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Expanded of FixedItem keys<br/>
	 */
	void cleanAllFixedItemExpandeds (
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Expanded for FixedItem Key<br/>
	 */
	String getFixedItemExpanded (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].expanded;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Expanded keys<br/>
	 */
	org.scn.community.shared.KeyArray getFixedItemExpandedKeysArray (
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.fixedItem);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].expanded == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the HasExpander for FixedItem keys<br/>
	 */
	void setFixedItemHasExpanders (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].hasExpander = true;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the HasExpander for FixedItem Key<br/>
	 */
	void setFixedItemHasExpander (
			/**/ String key,
			/**/ boolean hasExpander
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].hasExpander = hasExpander;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all HasExpander of FixedItem keys<br/>
	 */
	void cleanAllFixedItemHasExpanders (
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of HasExpander for FixedItem Key<br/>
	 */
	String getFixedItemHasExpander (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].hasExpander;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the HasExpander keys<br/>
	 */
	org.scn.community.shared.KeyArray getFixedItemHasExpanderKeysArray (
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.fixedItem);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].hasExpander == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Text for Items keys<br/>
	 */
	void setItemsTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Items Key<br/>
	 */
	void setItemsText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Items Key<br/>
	 */
	String getItemsText (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Items keys<br/>
	 */
	void setItemsIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.fixedItem = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Items Key<br/>
	 */
	void setItemsIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.fixedItem = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Items Key<br/>
	 */
	String getItemsIcon (
			/**/ String key
			) 
	{*
		if (this.fixedItem === undefined || this.fixedItem === "" || this.fixedItem === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.fixedItem);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Gets Fixed Item Selected Key Property
	 */	
	String getFixedItemSelectedKey() {*
		return this.fixedItemSelectedKey;
	*}

	/** Adds an element containing parentKey [String], key [String], text [String], icon [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	SIDENAVIGATION.addItems(parentKey [String], key [String], text [String], icon [String]);<br>
	SIDENAVIGATION.addItems(parentKey [String], key [String], text [String], icon [String]);
	</code>
	</example>
	 */
	void addItems (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**Text*/String text, 
			/**Icon*/optional String icon
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		if(icon == undefined) { icon = "";}
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			text:text, 
			icon:icon 
			};
	
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			this.item = "[]";
		}
		
		var elementsJson = JSON.parse(this.item);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.item = JSON.stringify(elementsJson);
	*}

	/** Adds a root element containing key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean].

 	<example>
	You want to add 2 root elements
	<code>
	SIDENAVIGATION.addItem(key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean]);<br>
	SIDENAVIGATION.addItem(key [String], text [String], icon [String], expanded [boolean], hasExpander [boolean]);<br>
	<br>
	</code>
	</example>
	 */
	void addItem (
			/**Unique Property Key*/String key, 
			/**Text*/String text, 
			/**Icon*/optional String icon, 
			/**Expanded*/optional boolean expanded, 
			/**Has Expander*/optional boolean hasExpander
			) {*		
		
		if(icon == undefined) { icon = "";}
		if(expanded == undefined) { expanded = false;}
		if(hasExpander == undefined) { hasExpander = false;}
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			text:text, 
			icon:icon, 
			expanded:expanded, 
			hasExpander:hasExpander 
			};
	
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			this.item = "[]";
		}
		
		var elementsJson = JSON.parse(this.item);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.item = JSON.stringify(elementsJson);
	*}
	
	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	SIDENAVIGATION.removeItems(String key);<br>
	</code>
	</example>
	 */
	void removeItems (
			String key
			) {*		
		
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			this.item = "[]";
		}
		
		var elementsJson = JSON.parse(this.item);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	SIDENAVIGATION.removeItem(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeItem (
			String key
			) {*		
		
		this.removeItems(key);
	*}

	/**
	 * Gets Items As JSON String
	 */	
	String getItemsAsJSON() {*
		var jsonObject = JSON.parse(this.item);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Items
	 */	
	String cleanAllItems() {*
		this.item = "[]";
	*}
	/**
	 * Sets the Text for Item keys<br/>
	 */
	void setItemTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Item Key<br/>
	 */
	void setItemText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Item Key<br/>
	 */
	String getItemText (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Item keys<br/>
	 */
	void setItemIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Item Key<br/>
	 */
	void setItemIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Item Key<br/>
	 */
	String getItemIcon (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Expanded for Item keys<br/>
	 */
	void setItemExpandeds (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].expanded = true;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Expanded for Item Key<br/>
	 */
	void setItemExpanded (
			/**/ String key,
			/**/ boolean expanded
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].expanded = expanded;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Expanded of Item keys<br/>
	 */
	void cleanAllItemExpandeds (
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].expanded = false;
		}
		
		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Expanded for Item Key<br/>
	 */
	String getItemExpanded (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].expanded;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Expanded keys<br/>
	 */
	org.scn.community.shared.KeyArray getItemExpandedKeysArray (
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.item);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].expanded == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the HasExpander for Item keys<br/>
	 */
	void setItemHasExpanders (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].hasExpander = true;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the HasExpander for Item Key<br/>
	 */
	void setItemHasExpander (
			/**/ String key,
			/**/ boolean hasExpander
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].hasExpander = hasExpander;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all HasExpander of Item keys<br/>
	 */
	void cleanAllItemHasExpanders (
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].hasExpander = false;
		}
		
		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of HasExpander for Item Key<br/>
	 */
	String getItemHasExpander (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].hasExpander;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the HasExpander keys<br/>
	 */
	org.scn.community.shared.KeyArray getItemHasExpanderKeysArray (
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.item);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].hasExpander == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the Text for Items keys<br/>
	 */
	void setItemsTexts (
			/**/ String keys,
			/**/ String separator,
	        /* Text */ String text
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].text = text;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Text for Items Key<br/>
	 */
	void setItemsText (
			/**/ String key,
			/**/ String text
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].text = text;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Text for Items Key<br/>
	 */
	String getItemsText (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].text;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Icon for Items keys<br/>
	 */
	void setItemsIcons (
			/**/ String keys,
			/**/ String separator,
	        /* Icon */ String icon
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.item);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].icon = icon;
					break;
				}
			}
		}
		
		this.item = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Icon for Items Key<br/>
	 */
	void setItemsIcon (
			/**/ String key,
			/**/ String icon
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].icon = icon;
				break;
			}
		}

		this.item = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Icon for Items Key<br/>
	 */
	String getItemsIcon (
			/**/ String key
			) 
	{*
		if (this.item === undefined || this.item === "" || this.item === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.item);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].icon;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Gets Item Selected Key Property
	 */	
	String getItemSelectedKey() {*
		return this.itemSelectedKey;
	*}














	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/* ZTL END */