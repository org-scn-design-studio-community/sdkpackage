/* GENERATED - DO NOT EDIT */
/**
 * Copyright 2015, Contributors
 * 
 * Original Source Code Location:
 *  https://github.com/org-scn-design-studio-community/sdkpackage/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */


class org.scn.community.databound.AdvancedDataTable extends org.scn.community.shared.DataComponent {
	
	/** returns the data */
	String getStringData () {*
		return this.stringData;	
	*}
}

/**
 * Generated ZTL Class for Breadcrumbs
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.Breadcrumbs extends org.scn.community.shared.ui5.Breadcrumbs {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Class for BulletChart
 */
class org.scn.community.databound.BulletChart extends org.scn.community.shared.Component {
	/* get the unique key for the clicked bullet chart */
    String getClickedGraphKey() {*  
    	return this.clickedgraphkey;
    *}

}
/**
 * Class for CalendarViz Properties
 */
class org.scn.community.databound.BarProperty {
  String title;
  String fillColor;
  String number;
  String numberUnit;
}

/**
 * Class for CalendarViz
 */
class org.scn.community.databound.CalendarViz extends org.scn.community.shared.Component {
	
}

/**
 * Generated ZTL Class for Clipboard
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.Clipboard extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Ignore Results Property
	 */	
	void setIgnoreResults( /**Ignore Results*/ boolean ignoreResults){*
		this.DIgnoreResults = ignoreResults;
	*}

	/**
	 * Gets Ignore Results Property
	 */	
	boolean isIgnoreResults() {*
		return this.DIgnoreResults;
	*}

	/**
	 * Sets Separator Property
	 */	
	void setSeparator( /**Separator*/ String separator){*
		this.DSeparator = separator;
	*}

	/**
	 * Gets Separator Property
	 */	
	String getSeparator() {*
		return this.DSeparator;
	*}

	/**
	 * Sets Show Keys instead of Texts Property
	 */	
	void setShowKeys( /**Show Keys instead of Texts*/ boolean showKeys){*
		this.DShowKeys = showKeys;
	*}

	/**
	 * Gets Show Keys instead of Texts Property
	 */	
	boolean isShowKeys() {*
		return this.DShowKeys;
	*}

	/**
	 * Sets Swap Axes Property
	 */	
	void setSwapAxes( /**Swap Axes*/ boolean swapAxes){*
		this.DSwapAxes = swapAxes;
	*}

	/**
	 * Gets Swap Axes Property
	 */	
	boolean isSwapAxes() {*
		return this.DSwapAxes;
	*}

	/**
	 * Sets Content Property
	 */	
	void setValue( /**Content*/ String value){*
		this.DValue = value;
	*}

	/**
	 * Gets Content Property
	 */	
	String getValue() {*
		return this.DValue;
	*}



	/**
	 * Sets Url For Picture Property
	 */	
	void setPicture( /**Url For Picture*/ String picture){*
		this.picture = picture;
	*}

	/**
	 * Gets Url For Picture Property
	 */	
	String getPicture() {*
		return this.picture;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
class org.scn.community.databound.Choropleth extends org.scn.community.shared.Component {
	/**
	Get selected feature
	*/
	String getSelectedFeature() {*
		return this.selectedFeature;
	*}
	/**
	Set Measure to use for coloring
	*/
	void setMeasure(/*Measure*/String measure) {*
		return this.measureMember = measure;
	*}
	/**
	Set Bubble Measure to use for coloring
	*/
	void setBubbleMeasure(/*Measure*/String measure) {*
		return this.bubbleMember = measure;
	*}
	/**
	Set Projection Method
	*/
	void setProjection(/*Projection*/String projection) {*
		this.projection = projection;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Bubble Color
	*/
	void setBubbleColor(/*Color*/String color) {*
		this.bubbleColor = color;
	*}
	/**
	Set Feature Attribute from GeoJSON that matches values in rows
	*/
	void setFeatureProperty(/*Attribute*/String attribute) {*
		this.featureProperty = attribute;
	*}
	/**
	Set Label Attribute from GeoJSON that should be used for labeling
	*/
	void setLabelProperty(/*Attribute*/String attribute) {*
		this.labelProperty = attribute;
	*}
}
/**
 * Generated ZTL Class for CustomMap
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.CustomMap extends org.scn.community.shared.Component {

	/**
	 * Sets Activate onMouseOver/Out Property
	 */	
	void setActivateOnMouseOverOut( /**Activate onMouseOver/Out*/ boolean activateOnMouseOverOut){*
		this.activateOnMouseOverOut = activateOnMouseOverOut;
	*}

	/**
	 * Gets Activate onMouseOver/Out Property
	 */	
	boolean isActivateOnMouseOverOut() {*
		return this.activateOnMouseOverOut;
	*}

	/**
	 * Sets Area are deselectable Property
	 */	
	void setAreaDeselectable( /**Area are deselectable*/ boolean areaDeselectable){*
		this.areaDeselectable = areaDeselectable;
	*}

	/**
	 * Gets Area are deselectable Property
	 */	
	boolean isAreaDeselectable() {*
		return this.areaDeselectable;
	*}

	/**
	 * Sets Fill Color Property
	 */	
	void setAreaFillColor( /**Fill Color*/ String areaFillColor){*
		this.areaFillColor = areaFillColor;
	*}

	/**
	 * Gets Fill Color Property
	 */	
	String getAreaFillColor() {*
		return this.areaFillColor;
	*}

	/**
	 * Sets Fill Opacity Property
	 */	
	void setAreaFillOpacity( /**Fill Opacity*/ float areaFillOpacity){*
		this.areaFillOpacity = areaFillOpacity;
	*}

	/**
	 * Gets Fill Opacity Property
	 */	
	float getAreaFillOpacity() {*
		return this.areaFillOpacity;
	*}

	/** Adds a root element containing key [String], fillColor [String], fillOpacity [float], strokeColor [String], strokeOpacity [float], strokeWidth [int], tooltip [String].

 	<example>
	You want to add 2 root elements
	<code>
	CUSTOMMAP.addAreaProperty(key [String], fillColor [String], fillOpacity [float], strokeColor [String], strokeOpacity [float], strokeWidth [int], tooltip [String]);<br>
	CUSTOMMAP.addAreaProperty(key [String], fillColor [String], fillOpacity [float], strokeColor [String], strokeOpacity [float], strokeWidth [int], tooltip [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addAreaProperty (
			/**key of the area*/String key, 
			/**Fill Color*/String fillColor, 
			/**Fill Opacity*/float fillOpacity, 
			/**Stroke Color*/String strokeColor, 
			/**Stroke Opacity*/float strokeOpacity, 
			/**Stroke Width*/int strokeWidth, 
			/**Tooltip*/String tooltip
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			fillColor:fillColor, 
			fillOpacity:fillOpacity, 
			strokeColor:strokeColor, 
			strokeOpacity:strokeOpacity, 
			strokeWidth:strokeWidth, 
			tooltip:tooltip
			};

		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			this.areaProperties = "[]";
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	CUSTOMMAP.removeAreaProperty(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeAreaProperty (
			String key
			) {*

		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			this.areaProperties = "[]";
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	CUSTOMMAP.insertAreaProperty(index [int], key [String], fillColor [String], fillOpacity [float], strokeColor [String], strokeOpacity [float], strokeWidth [int], tooltip [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertAreaProperty (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**key of the area*/String key, 
			/**Fill Color*/String fillColor, 
			/**Fill Opacity*/float fillOpacity, 
			/**Stroke Color*/String strokeColor, 
			/**Stroke Opacity*/float strokeOpacity, 
			/**Stroke Width*/int strokeWidth, 
			/**Tooltip*/String tooltip
			) {*

		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			this.areaProperties = "[]";
		}
		
		var elementsJson = JSON.parse(this.areaProperties);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			fillColor:fillColor, 
			fillOpacity:fillOpacity, 
			strokeColor:strokeColor, 
			strokeOpacity:strokeOpacity, 
			strokeWidth:strokeWidth, 
			tooltip:tooltip
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.areaProperties = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given AreaProperty<br/>
	 */
	void updateAreaProperty (
			/**key of the area*/String key, 
			/**Fill Color*/String fillColor, 
			/**Fill Opacity*/float fillOpacity, 
			/**Stroke Color*/String strokeColor, 
			/**Stroke Opacity*/float strokeOpacity, 
			/**Stroke Width*/int strokeWidth, 
			/**Tooltip*/String tooltip
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			this.areaProperties = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			fillColor:fillColor, 
			fillOpacity:fillOpacity, 
			strokeColor:strokeColor, 
			strokeOpacity:strokeOpacity, 
			strokeWidth:strokeWidth, 
			tooltip:tooltip
		};

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getAreaPropertyAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			this.areaProperties = "[]";
		}

		var elementsJson = JSON.parse(this.areaProperties);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets AreaPropertys As JSON String
	 */	
	String getAreaPropertysAsJSON() {*
		var jsonObject = JSON.parse(this.areaProperties);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All AreaPropertys
	 */	
	String cleanAllAreaPropertys() {*
		this.areaProperties = "[]";
	*}
	
	/**
	 * Sets the FillColor for AreaProperty keys<br/>
	 */
	void setAreaPropertyFillColors (
			/**/ String keys,
			/**/ String separator,
	        /* FillColor */ String fillColor
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fillColor = fillColor;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FillColor for AreaProperty Key<br/>
	 */
	void setAreaPropertyFillColor (
			/**/ String key,
			/**/ String fillColor
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fillColor = fillColor;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of FillColor for AreaProperty Key<br/>
	 */
	String getAreaPropertyFillColor (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].fillColor;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the FillOpacity for AreaProperty keys<br/>
	 */
	void setAreaPropertyFillOpacitys (
			/**/ String keys,
			/**/ String separator,
	        /* FillOpacity */ float fillOpacity
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fillOpacity = fillOpacity;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FillOpacity for AreaProperty Key<br/>
	 */
	void setAreaPropertyFillOpacity (
			/**/ String key,
			/**/ float fillOpacity
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fillOpacity = fillOpacity;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of FillOpacity for AreaProperty Key<br/>
	 */
	float getAreaPropertyFillOpacity (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].fillOpacity;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the StrokeColor for AreaProperty keys<br/>
	 */
	void setAreaPropertyStrokeColors (
			/**/ String keys,
			/**/ String separator,
	        /* StrokeColor */ String strokeColor
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].strokeColor = strokeColor;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the StrokeColor for AreaProperty Key<br/>
	 */
	void setAreaPropertyStrokeColor (
			/**/ String key,
			/**/ String strokeColor
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].strokeColor = strokeColor;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of StrokeColor for AreaProperty Key<br/>
	 */
	String getAreaPropertyStrokeColor (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].strokeColor;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the StrokeOpacity for AreaProperty keys<br/>
	 */
	void setAreaPropertyStrokeOpacitys (
			/**/ String keys,
			/**/ String separator,
	        /* StrokeOpacity */ float strokeOpacity
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].strokeOpacity = strokeOpacity;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the StrokeOpacity for AreaProperty Key<br/>
	 */
	void setAreaPropertyStrokeOpacity (
			/**/ String key,
			/**/ float strokeOpacity
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].strokeOpacity = strokeOpacity;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of StrokeOpacity for AreaProperty Key<br/>
	 */
	float getAreaPropertyStrokeOpacity (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].strokeOpacity;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the StrokeWidth for AreaProperty keys<br/>
	 */
	void setAreaPropertyStrokeWidths (
			/**/ String keys,
			/**/ String separator,
	        /* StrokeWidth */ int strokeWidth
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].strokeWidth = strokeWidth;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the StrokeWidth for AreaProperty Key<br/>
	 */
	void setAreaPropertyStrokeWidth (
			/**/ String key,
			/**/ int strokeWidth
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].strokeWidth = strokeWidth;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of StrokeWidth for AreaProperty Key<br/>
	 */
	int getAreaPropertyStrokeWidth (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].strokeWidth;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Tooltip for AreaProperty keys<br/>
	 */
	void setAreaPropertyTooltips (
			/**/ String keys,
			/**/ String separator,
	        /* Tooltip */ String tooltip
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].tooltip = tooltip;
					break;
				}
			}
		}
		
		this.areaProperties = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Tooltip for AreaProperty Key<br/>
	 */
	void setAreaPropertyTooltip (
			/**/ String key,
			/**/ String tooltip
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].tooltip = tooltip;
				break;
			}
		}

		this.areaProperties = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Tooltip for AreaProperty Key<br/>
	 */
	String getAreaPropertyTooltip (
			/**/ String key
			) 
	{*
		if (this.areaProperties === undefined || this.areaProperties === "" || this.areaProperties === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.areaProperties);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].tooltip;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Area are selectable Property
	 */	
	void setAreaSelectable( /**Area are selectable*/ boolean areaSelectable){*
		this.areaSelectable = areaSelectable;
	*}

	/**
	 * Gets Area are selectable Property
	 */	
	boolean isAreaSelectable() {*
		return this.areaSelectable;
	*}

	/**
	 * Sets Stroke Color Property
	 */	
	void setAreaStrokeColor( /**Stroke Color*/ String areaStrokeColor){*
		this.areaStrokeColor = areaStrokeColor;
	*}

	/**
	 * Gets Stroke Color Property
	 */	
	String getAreaStrokeColor() {*
		return this.areaStrokeColor;
	*}

	/**
	 * Sets Stroke Opacity Property
	 */	
	void setAreaStrokeOpacity( /**Stroke Opacity*/ float areaStrokeOpacity){*
		this.areaStrokeOpacity = areaStrokeOpacity;
	*}

	/**
	 * Gets Stroke Opacity Property
	 */	
	float getAreaStrokeOpacity() {*
		return this.areaStrokeOpacity;
	*}

	/**
	 * Sets Stroke Width Property
	 */	
	void setAreaStrokeWidth( /**Stroke Width*/ int areaStrokeWidth){*
		this.areaStrokeWidth = areaStrokeWidth;
	*}

	/**
	 * Gets Stroke Width Property
	 */	
	int getAreaStrokeWidth() {*
		return this.areaStrokeWidth;
	*}

	/**
	 * Sets Auto resize Property
	 */	
	void setAutoResize( /**Auto resize*/ boolean autoResize){*
		this.autoResize = autoResize;
	*}

	/**
	 * Gets Auto resize Property
	 */	
	boolean isAutoResize() {*
		return this.autoResize;
	*}

	/**
	 * Sets Tooltip template (html + Mustache) Property
	 */	
	void setContentTooltip( /**Tooltip template (html + Mustache)*/ String contentTooltip){*
		this.contentTooltip = contentTooltip;
	*}

	/**
	 * Gets Tooltip template (html + Mustache) Property
	 */	
	String getContentTooltip() {*
		return this.contentTooltip;
	*}

	/**
	 * Sets Data List Property
	 */	
	void setData( /**Data List*/ ResultSet data){*
		this.data = data;
	*}

	/**
	 * Gets Data List Property
	 */	
	ResultSet getData() {*
		return this.data;
	*}

	/**
	 * Sets Reference Measure Selection Property
	 */	
	void setDataCellList( /**Reference Measure Selection*/ ResultCellList dataCellList){*
		this.dataCellList = dataCellList;
	*}

	/**
	 * Gets Reference Measure Selection Property
	 */	
	ResultCellList getDataCellList() {*
		return this.dataCellList;
	*}



	/**
	 * Sets Activate Strokes Property
	 */	
	void setDisplayStroke( /**Activate Strokes*/ boolean displayStroke){*
		this.displayStroke = displayStroke;
	*}

	/**
	 * Gets Activate Strokes Property
	 */	
	boolean isDisplayStroke() {*
		return this.displayStroke;
	*}

	/**
	 * Sets Display Tooltip Property
	 */	
	void setDisplayTooltip( /**Display Tooltip*/ boolean displayTooltip){*
		this.displayTooltip = displayTooltip;
	*}

	/**
	 * Gets Display Tooltip Property
	 */	
	boolean isDisplayTooltip() {*
		return this.displayTooltip;
	*}

	/**
	 * Sets Color Palette Property
	 */	
	void setDynamicColorPalette( /**Color Palette*/ String dynamicColorPalette){*
		this.dynamicColorPalette = dynamicColorPalette;
	*}

	/**
	 * Gets Color Palette Property
	 */	
	String getDynamicColorPalette() {*
		return this.dynamicColorPalette;
	*}

	/**
	 * Sets enable Fill Properties Property
	 */	
	void setEnableAreaFill( /**enable Fill Properties*/ boolean enableAreaFill){*
		this.enableAreaFill = enableAreaFill;
	*}

	/**
	 * Gets enable Fill Properties Property
	 */	
	boolean isEnableAreaFill() {*
		return this.enableAreaFill;
	*}

	/**
	 * Sets Enable Dynamic Colors Property
	 */	
	void setEnableDynamicColors( /**Enable Dynamic Colors*/ boolean enableDynamicColors){*
		this.enableDynamicColors = enableDynamicColors;
	*}

	/**
	 * Gets Enable Dynamic Colors Property
	 */	
	boolean isEnableDynamicColors() {*
		return this.enableDynamicColors;
	*}

	/**
	 * Sets Activate special properties on Highlight Property
	 */	
	void setEnableSpecificPropHighlight( /**Activate special properties on Highlight*/ boolean enableSpecificPropHighlight){*
		this.enableSpecificPropHighlight = enableSpecificPropHighlight;
	*}

	/**
	 * Gets Activate special properties on Highlight Property
	 */	
	boolean isEnableSpecificPropHighlight() {*
		return this.enableSpecificPropHighlight;
	*}

	/**
	 * Sets Activate special properties when Selected Property
	 */	
	void setEnableSpecificPropSelected( /**Activate special properties when Selected*/ boolean enableSpecificPropSelected){*
		this.enableSpecificPropSelected = enableSpecificPropSelected;
	*}

	/**
	 * Gets Activate special properties when Selected Property
	 */	
	boolean isEnableSpecificPropSelected() {*
		return this.enableSpecificPropSelected;
	*}

	/**
	 * Sets Fill Color Property
	 */	
	void setHighlightFillColor( /**Fill Color*/ String highlightFillColor){*
		this.highlightFillColor = highlightFillColor;
	*}

	/**
	 * Gets Fill Color Property
	 */	
	String getHighlightFillColor() {*
		return this.highlightFillColor;
	*}

	/**
	 * Sets Fill Opacity Property
	 */	
	void setHighlightFillOpacity( /**Fill Opacity*/ float highlightFillOpacity){*
		this.highlightFillOpacity = highlightFillOpacity;
	*}

	/**
	 * Gets Fill Opacity Property
	 */	
	float getHighlightFillOpacity() {*
		return this.highlightFillOpacity;
	*}

	/**
	 * Sets Stroke Color Property
	 */	
	void setHighlightStrokeColor( /**Stroke Color*/ String highlightStrokeColor){*
		this.highlightStrokeColor = highlightStrokeColor;
	*}

	/**
	 * Gets Stroke Color Property
	 */	
	String getHighlightStrokeColor() {*
		return this.highlightStrokeColor;
	*}

	/**
	 * Sets Stroke Opacity Property
	 */	
	void setHighlightStrokeOpacity( /**Stroke Opacity*/ float highlightStrokeOpacity){*
		this.highlightStrokeOpacity = highlightStrokeOpacity;
	*}

	/**
	 * Gets Stroke Opacity Property
	 */	
	float getHighlightStrokeOpacity() {*
		return this.highlightStrokeOpacity;
	*}

	/**
	 * Sets Stroke Width Property
	 */	
	void setHighlightStrokeWidth( /**Stroke Width*/ int highlightStrokeWidth){*
		this.highlightStrokeWidth = highlightStrokeWidth;
	*}

	/**
	 * Gets Stroke Width Property
	 */	
	int getHighlightStrokeWidth() {*
		return this.highlightStrokeWidth;
	*}

	/**
	 * Gets  Property
	 */	
	String getHighlightedArea() {*
		return this.highlightedArea;
	*}

	/**
	 * Sets Image url of Base 64 Property
	 */	
	void setImage( /**Image url of Base 64*/ String image){*
		this.image = image;
	*}

	/**
	 * Gets Image url of Base 64 Property
	 */	
	String getImage() {*
		return this.image;
	*}

	/**
	 * Sets Associated map, same scaling as base image Property
	 */	
	void setMap( /**Associated map, same scaling as base image*/ String map){*
		this.map = map;
	*}

	/**
	 * Gets Associated map, same scaling as base image Property
	 */	
	String getMap() {*
		return this.map;
	*}

	/**
	 * Sets Map key attribute Property
	 */	
	void setMapDataKey( /**Map key attribute*/ String mapDataKey){*
		this.mapDataKey = mapDataKey;
	*}

	/**
	 * Gets Map key attribute Property
	 */	
	String getMapDataKey() {*
		return this.mapDataKey;
	*}









	/**
	 * Sets Single Select Property
	 */	
	void setOnlySingleSelect( /**Single Select*/ boolean onlySingleSelect){*
		this.onlySingleSelect = onlySingleSelect;
	*}

	/**
	 * Gets Single Select Property
	 */	
	boolean isOnlySingleSelect() {*
		return this.onlySingleSelect;
	*}

	/**
	 * Sets Resize Duration (ms) Property
	 */	
	void setResizeDuration( /**Resize Duration (ms)*/ int resizeDuration){*
		this.resizeDuration = resizeDuration;
	*}

	/**
	 * Gets Resize Duration (ms) Property
	 */	
	int getResizeDuration() {*
		return this.resizeDuration;
	*}

	/**
	 * Sets  Property
	 */	
	void setSelectedAreas( /***/ String selectedAreas){*
		this.selectedAreas = selectedAreas;
	*}

	/**
	 * Gets  Property
	 */	
	String getSelectedAreas() {*
		return this.selectedAreas;
	*}

	/**
	 * Sets Fill Color Property
	 */	
	void setSelectedFillColor( /**Fill Color*/ String selectedFillColor){*
		this.selectedFillColor = selectedFillColor;
	*}

	/**
	 * Gets Fill Color Property
	 */	
	String getSelectedFillColor() {*
		return this.selectedFillColor;
	*}

	/**
	 * Sets Fill Opacity Property
	 */	
	void setSelectedFillOpacity( /**Fill Opacity*/ float selectedFillOpacity){*
		this.selectedFillOpacity = selectedFillOpacity;
	*}

	/**
	 * Gets Fill Opacity Property
	 */	
	float getSelectedFillOpacity() {*
		return this.selectedFillOpacity;
	*}

	/**
	 * Sets Stroke Color Property
	 */	
	void setSelectedStrokeColor( /**Stroke Color*/ String selectedStrokeColor){*
		this.selectedStrokeColor = selectedStrokeColor;
	*}

	/**
	 * Gets Stroke Color Property
	 */	
	String getSelectedStrokeColor() {*
		return this.selectedStrokeColor;
	*}

	/**
	 * Sets Stroke Opacity Property
	 */	
	void setSelectedStrokeOpacity( /**Stroke Opacity*/ float selectedStrokeOpacity){*
		this.selectedStrokeOpacity = selectedStrokeOpacity;
	*}

	/**
	 * Gets Stroke Opacity Property
	 */	
	float getSelectedStrokeOpacity() {*
		return this.selectedStrokeOpacity;
	*}

	/**
	 * Sets Stroke Width Property
	 */	
	void setSelectedStrokeWidth( /**Stroke Width*/ int selectedStrokeWidth){*
		this.selectedStrokeWidth = selectedStrokeWidth;
	*}

	/**
	 * Gets Stroke Width Property
	 */	
	int getSelectedStrokeWidth() {*
		return this.selectedStrokeWidth;
	*}

	/**
	 * Sets Display all areas by default Property
	 */	
	void setStaticDisplay( /**Display all areas by default*/ boolean staticDisplay){*
		this.staticDisplay = staticDisplay;
	*}

	/**
	 * Gets Display all areas by default Property
	 */	
	boolean isStaticDisplay() {*
		return this.staticDisplay;
	*}

	/**
	 * Sets Tooltip override mode Property
	 */	
	void setTooltipMode( /**Tooltip override mode*/ String tooltipMode){*
		this.tooltipMode = tooltipMode;
	*}

	/**
	 * Gets Tooltip override mode Property
	 */	
	String getTooltipMode() {*
		return this.tooltipMode;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

/**
 * Get selected areas as an array
 */	
Array getSelectedAreasAsArray(){*
	return this.getSelectedAreas().split(",");
*}
	
}

/**
 * Generated ZTL Class for DropDown
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.DropDown extends org.scn.community.shared.Component {

	/**
	 * Sets Binding Mode (metadata, Resultset) Property by String
	 */	
	void setBindingModeByString( /**Binding Mode (metadata, Resultset)*/ String bindingMode){*
		this.DBindingMode = bindingMode;
	*}

	/**
	 * Gets Binding Mode (metadata, Resultset) Property as String
	 */	
	String getBindingModeAsString() {*
		return this.DBindingMode;
	*}
	
	/**
	 * Sets Binding Mode (metadata, Resultset) Property by Choice Option
	 */	
	void setBindingMode( /**Binding Mode (metadata, Resultset)*/ org_scn_community_shared_Enumfield bindingMode){*
		this.DBindingMode = bindingMode;
	*}
	
	/**
	 * Gets Binding Mode (metadata, Resultset) Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getBindingMode() {*
		return this.DBindingMode;
	*}

	/**
	 * Sets Selected Dimension Property
	 */	
	void setDimension( /**Selected Dimension*/ String dimension){*
		this.DDimension = dimension;
	*}

	/**
	 * Gets Selected Dimension Property
	 */	
	String getDimension() {*
		return this.DDimension;
	*}

	/**
	 * Gets Technical Proprty For Pause Refresh Property
	 */	
	boolean isDoRefresh() {*
		return this.DDoRefresh;
	*}

	/**
	 * Gets Master Data Elements Property
	 */	
	String getElements() {*
		return this.DElements;
	*}

	/**
	 * Sets Maximum Numner Of Members Property
	 */	
	void setMaxMembers( /**Maximum Numner Of Members*/ int maxMembers){*
		this.DMaxMembers = maxMembers;
	*}

	/**
	 * Gets Maximum Numner Of Members Property
	 */	
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Gets Technical Proprty For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.DSelectedKey;
	*}

	/**
	 * Gets Technical Proprty For Selected Key Property
	 */	
	String getSelectedKeyExt() {*
		return this.DSelectedKeyExt;
	*}

	/**
	 * Gets Technical Proprty For Selected External String Full Property
	 */	
	String getSelectedKeyExtFull() {*
		return this.DSelectedKeyExtFull;
	*}

	/**
	 * Gets Technical Proprty For Selected Text Property
	 */	
	String getSelectedText() {*
		return this.DSelectedText;
	*}

	/**
	 * Sets Sorting By Value | Defalut Property by String
	 */	
	void setSortingByString( /**Sorting By Value | Defalut*/ String sorting){*
		this.DSorting = sorting;
	*}

	/**
	 * Gets Sorting By Value | Defalut Property as String
	 */	
	String getSortingAsString() {*
		return this.DSorting;
	*}
	
	/**
	 * Sets Sorting By Value | Defalut Property by Choice Option
	 */	
	void setSorting( /**Sorting By Value | Defalut*/ org_scn_community_shared_Enumfield sorting){*
		this.DSorting = sorting;
	*}
	
	/**
	 * Gets Sorting By Value | Defalut Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getSorting() {*
		return this.DSorting;
	*}

	/**
	 * Sets Top X, Bottom X Or Both Property by String
	 */	
	void setTopBottomByString( /**Top X, Bottom X Or Both*/ String topBottom){*
		this.DTopBottom = topBottom;
	*}

	/**
	 * Gets Top X, Bottom X Or Both Property as String
	 */	
	String getTopBottomAsString() {*
		return this.DTopBottom;
	*}
	
	/**
	 * Sets Top X, Bottom X Or Both Property by Choice Option
	 */	
	void setTopBottom( /**Top X, Bottom X Or Both*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.DTopBottom = topBottom;
	*}
	
	/**
	 * Gets Top X, Bottom X Or Both Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.DTopBottom;
	*}












	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	void private_onSelectionChanged () {*
		var key = this.getSelectedKey();
	
		this.internalWriteLog("Internal Selection on Dimension: " + this.getDimension() + " | " + key);

		if(key == "-CLEAR-") {
			this.getDataSource().clearFilter(this.getDimension());
		} else {
			this.getDataSource().setFilter(this.getDimension(), key);	
		}
	*}
	
	void private_onBeforeRender() {*
		
	*}
	
	void reloadDataSource() {*
		// unfortunately this does not work correctly as this method is too late included (as first method on rendering, instead on before rendering)
		// this causes incorrect events in a phase where events are not allowed any more... (error: DS_1 cannot be changed in rendering phase)
		// workaround is to call once explicitelly "getMembers" on this dimension
		if(this.DBindingMode == "Master Data") {
			this.internalWriteLog("Call Members on Dimension: " + this.getDimension() + " | " + this.DMaxMembers);
			this.DElements = this.superReadMembers(this.getDimension(), this.DMaxMembers);	
		}
	
		// check current selection from data source
		var selectionExt = this.getDataSource().getFilterExt(this.getDimension());
		this.internalWriteLog("Selection on Dimension: " + this.getDimension() + " | " + selectionExt);

		this.DSelectedKeyExtFull = selectionExt;
		
		// only single member
		if(selectionExt.indexOf(";") == -1 && selectionExt.indexOf(" - ") == -1) {
			this.DSelectedKeyExt = selectionExt;	
		} else {
			this.DSelectedKeyExt = "";
		}
	*}

	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.DDoRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.DDoRefresh = true;	
	*}

}

/**
 * Class for D3Hier
 */
class org.scn.community.databound.jpd3hier extends org.scn.community.shared.DataComponent {

	/* Returns the Key of the currently selected Tree Element. */
	String getSelectedNodeKey() {*
		return this.selectedNode;
	*}
	
	/* Returns the Dimension Key containing the hierarchy of the datasource. */
	String getHierarchyDimensionKey() {*
		return this.dimHierarchy;
	*}
	
	/* Returns the maximum Size of the Bubbles in Pixel */
	String getBubbleSizeMaxSize() {*
		return this.BubbleSizeMaxSize;
	*}
	
	/* Sets the maximum Size of the Bubbles in Pixel */
	void setBubbleSizeMaxSize(/* New maximum Bubble size in Pixel */ int newBubbleSize) {*
		this.BubbleSizeMaxSize = newBubbleSize;
	*}
	
	/* Sets the Bubble Size Keyfigure id during runtime */
	void setkfBubbleSize(/* New id of a keyfigure column */ String newkfBubbleSizeId) {*
		this.kfBubbleSize = newkfBubbleSizeId;
	*}
	
	/* Gets the Bubble Size Keyfigure id during runtime */
	void getkfBubbleSize() {*
		return this.kfBubbleSize;
	*}
	
	/* Sets the Bubble Alerter Keyfigure id during runtime */
	void setkfBubbleAlerter(/* New id of a keyfigure column */ String newkfBubbleAlerterId) {*
		this.kfColBub = newkfBubbleAlerterId;
	*}
	
	/* Gets the Bubble Alerter Keyfigure id during runtime */
	void getkfBubbleAlerter() {*
		return this.kfColBub;
	*}
	
	/* Sets the Bubble Alerter Color Value for Green during runtime */
	void setAlerterColorGreenVal(/* New value for the Bubble color Green*/ int newAlerterColorGreenVal) {*
		this.AlerterColorGreenVal = newAlerterColorGreenVal;
	*}
	
	/* Sets the Bubble Alerter Color Value for Yellow during runtime */
	void setAlerterColorYellowVal(/* New value for the Bubble color Yellow*/ int newAlerterColorYellowVal) {*
		this.AlerterColorYellowVal = newAlerterColorYellowVal;
	*}
	
	/* Returns the x-translation of the whole tree in Pixel */
	String getBubbleRootXTranslation() {*
		return this.BubbleRootXTranslation;
	*}
	/* Sets the x-translation of the whole tree in Pixel */
	void setBubbleRootXTranslation(/* New x translation in Pixel -> positive = right, negative = left*/ int newXTranslation) {*
		this.BubbleRootXTranslation = newXTranslation;
	*}
	
	
	/* Expand the hierarchy */
	void expandHierarchyNodes() {*
	    this.getDataSource().expandNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Collapse the hierarchy */
	void collapseHierarchyNodes() {*
		this.getDataSource().collapseNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
}

/**
 * Generated ZTL Class for FacetFilter
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FacetFilter extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Clear Selections if 0 Property
	 */	
	void setClearOthers( /**Clear Selections if 0*/ boolean clearOthers){*
		this.DClearOthers = clearOthers;
	*}

	/**
	 * Gets Clear Selections if 0 Property
	 */	
	boolean isClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets Content Mode Property by String
	 */	
	void setContentModeByString( /**Content Mode*/ String contentMode){*
		this.DContentMode = contentMode;
	*}

	/**
	 * Gets Content Mode Property as String
	 */	
	String getContentModeAsString() {*
		return this.DContentMode;
	*}
	
	/**
	 * Sets Content Mode Property by Choice Option
	 */	
	void setContentMode( /**Content Mode*/ org_scn_community_shared_DimensionSetEnumfield contentMode){*
		this.DContentMode = contentMode;
	*}
	
	/**
	 * Gets Content Mode Property as Choice Option
	 */	
	org_scn_community_shared_DimensionSetEnumfield getContentMode() {*
		return this.DContentMode;
	*}

	/**
	 * Sets Custom Dimensions Property as StringArray
	 */	
	void setCustomDimensions( /**Custom Dimensions*/ StringArray customDimensions){*
		this.DCustomDimensions = customDimensions;
	*}
	
	/** Gets Custom Dimensions Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	FACETFILTER.getCustomDimensions();<br>
	</code>
	</example>
	 */
	StringArray getCustomDimensions () {*		
		var elementsJson = JSON.parse(this.DCustomDimensions);
		return elementsJson;
	*}

	/**
	 * Sets Display Text Property by String
	 */	
	void setDisplayTextByString( /**Display Text*/ String displayText){*
		this.DDisplayText = displayText;
	*}

	/**
	 * Gets Display Text Property as String
	 */	
	String getDisplayTextAsString() {*
		return this.DDisplayText;
	*}
	
	/**
	 * Sets Display Text Property by Choice Option
	 */	
	void setDisplayText( /**Display Text*/ org_scn_community_shared_MemberDisplayEnumfield displayText){*
		this.DDisplayText = displayText;
	*}
	
	/**
	 * Gets Display Text Property as Choice Option
	 */	
	org_scn_community_shared_MemberDisplayEnumfield getDisplayText() {*
		return this.DDisplayText;
	*}



	/**
	 * Sets Facet Width in px Property
	 */	
	void setFacetWidth( /**Facet Width in px*/ int facetWidth){*
		this.DFacetWidth = facetWidth;
	*}

	/**
	 * Gets Facet Width in px Property
	 */	
	int getFacetWidth() {*
		return this.DFacetWidth;
	*}

	/**
	 * Sets Maximum Members for Display Property
	 */	
	void setMaxDisplayMembers( /**Maximum Members for Display*/ int maxDisplayMembers){*
		this.DMaxDisplayMembers = maxDisplayMembers;
	*}

	/**
	 * Gets Maximum Members for Display Property
	 */	
	int getMaxDisplayMembers() {*
		return this.DMaxDisplayMembers;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxMembers( /**Maximum Number of Members*/ int maxMembers){*
		this.DMaxMembers = maxMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Sets Second Value Content Property by String
	 */	
	void setSecondValueContentByString( /**Second Value Content*/ String secondValueContent){*
		this.DSecondValueContent = secondValueContent;
	*}

	/**
	 * Gets Second Value Content Property as String
	 */	
	String getSecondValueContentAsString() {*
		return this.DSecondValueContent;
	*}
	
	/**
	 * Sets Second Value Content Property by Choice Option
	 */	
	void setSecondValueContent( /**Second Value Content*/ org_scn_community_shared_SecondValueContentEnumfield secondValueContent){*
		this.DSecondValueContent = secondValueContent;
	*}
	
	/**
	 * Gets Second Value Content Property as Choice Option
	 */	
	org_scn_community_shared_SecondValueContentEnumfield getSecondValueContent() {*
		return this.DSecondValueContent;
	*}



	/**
	 * Sets Show Second Value Property
	 */	
	void setShowSecondValue( /**Show Second Value*/ boolean showSecondValue){*
		this.DShowSecondValue = showSecondValue;
	*}

	/**
	 * Gets Show Second Value Property
	 */	
	boolean isShowSecondValue() {*
		return this.DShowSecondValue;
	*}

	/**
	 * Sets Member Sorting Direction Property by String
	 */	
	void setSortingDirectionByString( /**Member Sorting Direction*/ String sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}

	/**
	 * Gets Member Sorting Direction Property as String
	 */	
	String getSortingDirectionAsString() {*
		return this.DSortingDirection;
	*}
	
	/**
	 * Sets Member Sorting Direction Property by Choice Option
	 */	
	void setSortingDirection( /**Member Sorting Direction*/ org_scn_community_shared_SortDirectionEnumfield sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}
	
	/**
	 * Gets Member Sorting Direction Property as Choice Option
	 */	
	org_scn_community_shared_SortDirectionEnumfield getSortingDirection() {*
		return this.DSortingDirection;
	*}

	/**
	 * Sets Member Sorting Type Property by String
	 */	
	void setSortingTypeByString( /**Member Sorting Type*/ String sortingType){*
		this.DSortingType = sortingType;
	*}

	/**
	 * Gets Member Sorting Type Property as String
	 */	
	String getSortingTypeAsString() {*
		return this.DSortingType;
	*}
	
	/**
	 * Sets Member Sorting Type Property by Choice Option
	 */	
	void setSortingType( /**Member Sorting Type*/ org_scn_community_shared_SortTypeEnumfield sortingType){*
		this.DSortingType = sortingType;
	*}
	
	/**
	 * Gets Member Sorting Type Property as Choice Option
	 */	
	org_scn_community_shared_SortTypeEnumfield getSortingType() {*
		return this.DSortingType;
	*}

	/**
	 * Sets Zero Values Display Mode Property by String
	 */	
	void setZeroValuesModeByString( /**Zero Values Display Mode*/ String zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}

	/**
	 * Gets Zero Values Display Mode Property as String
	 */	
	String getZeroValuesModeAsString() {*
		return this.DZeroValuesMode;
	*}
	
	/**
	 * Sets Zero Values Display Mode Property by Choice Option
	 */	
	void setZeroValuesMode( /**Zero Values Display Mode*/ org_scn_community_shared_Enumfield zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}
	
	/**
	 * Gets Zero Values Display Mode Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getZeroValuesMode() {*
		return this.DZeroValuesMode;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Reads the Dimensions from Data Source 
	 */
	@Visibility(private)
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Resultset") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.dimensions = [];
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.dimensionsAll.forEach(function(dimension, indexD) {
					if(dimension.name == l.customDimensions[iD]) {
						l.dimensions.push(dimension);
					}
				});
			}
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}

	/**
	 * Resets the actual data of all dimensions (and causes reload of all members in "reloadDataSource" method.
	 * Use it together like below
	 * <example>
	 * You want to reload actual members again
	 * <code>
	 * FACET.resetDimensions();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 */
	void resetDimensions() {*
		this.oldDimensionKeys = "";
	*}

	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}

	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACET.reloadDataSource();
	 * 
	 * // every time 
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	@Visibility(private)
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.isClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

}

/**
 * Generated ZTL Class for FacetSelector
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FacetSelector extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Clear Selections if 0 Property
	 */	
	void setClearOthers( /**Clear Selections if 0*/ boolean clearOthers){*
		this.DClearOthers = clearOthers;
	*}

	/**
	 * Gets Clear Selections if 0 Property
	 */	
	boolean isClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets Content Mode Property by String
	 */	
	void setContentModeByString( /**Content Mode*/ String contentMode){*
		this.DContentMode = contentMode;
	*}

	/**
	 * Gets Content Mode Property as String
	 */	
	String getContentModeAsString() {*
		return this.DContentMode;
	*}
	
	/**
	 * Sets Content Mode Property by Choice Option
	 */	
	void setContentMode( /**Content Mode*/ org_scn_community_shared_DimensionSetEnumfield contentMode){*
		this.DContentMode = contentMode;
	*}
	
	/**
	 * Gets Content Mode Property as Choice Option
	 */	
	org_scn_community_shared_DimensionSetEnumfield getContentMode() {*
		return this.DContentMode;
	*}

	/**
	 * Sets Custom Dimensions Property as StringArray
	 */	
	void setCustomDimensions( /**Custom Dimensions*/ StringArray customDimensions){*
		this.DCustomDimensions = customDimensions;
	*}
	
	/** Gets Custom Dimensions Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	FACETSELECTOR.getCustomDimensions();<br>
	</code>
	</example>
	 */
	StringArray getCustomDimensions () {*		
		var elementsJson = JSON.parse(this.DCustomDimensions);
		return elementsJson;
	*}

	/**
	 * Sets Display Text Property by String
	 */	
	void setDisplayTextByString( /**Display Text*/ String displayText){*
		this.DDisplayText = displayText;
	*}

	/**
	 * Gets Display Text Property as String
	 */	
	String getDisplayTextAsString() {*
		return this.DDisplayText;
	*}
	
	/**
	 * Sets Display Text Property by Choice Option
	 */	
	void setDisplayText( /**Display Text*/ org_scn_community_shared_MemberDisplayEnumfield displayText){*
		this.DDisplayText = displayText;
	*}
	
	/**
	 * Gets Display Text Property as Choice Option
	 */	
	org_scn_community_shared_MemberDisplayEnumfield getDisplayText() {*
		return this.DDisplayText;
	*}



	/**
	 * Sets Facet Width in px Property
	 */	
	void setFacetWidth( /**Facet Width in px*/ int facetWidth){*
		this.DFacetWidth = facetWidth;
	*}

	/**
	 * Gets Facet Width in px Property
	 */	
	int getFacetWidth() {*
		return this.DFacetWidth;
	*}

	/**
	 * Sets Maximum Members for Display Property
	 */	
	void setMaxDisplayMembers( /**Maximum Members for Display*/ int maxDisplayMembers){*
		this.DMaxDisplayMembers = maxDisplayMembers;
	*}

	/**
	 * Gets Maximum Members for Display Property
	 */	
	int getMaxDisplayMembers() {*
		return this.DMaxDisplayMembers;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxMembers( /**Maximum Number of Members*/ int maxMembers){*
		this.DMaxMembers = maxMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}



	/**
	 * Sets Member Sorting Direction Property by String
	 */	
	void setSortingDirectionByString( /**Member Sorting Direction*/ String sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}

	/**
	 * Gets Member Sorting Direction Property as String
	 */	
	String getSortingDirectionAsString() {*
		return this.DSortingDirection;
	*}
	
	/**
	 * Sets Member Sorting Direction Property by Choice Option
	 */	
	void setSortingDirection( /**Member Sorting Direction*/ org_scn_community_shared_SortDirectionEnumfield sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}
	
	/**
	 * Gets Member Sorting Direction Property as Choice Option
	 */	
	org_scn_community_shared_SortDirectionEnumfield getSortingDirection() {*
		return this.DSortingDirection;
	*}

	/**
	 * Sets Member Sorting Type Property by String
	 */	
	void setSortingTypeByString( /**Member Sorting Type*/ String sortingType){*
		this.DSortingType = sortingType;
	*}

	/**
	 * Gets Member Sorting Type Property as String
	 */	
	String getSortingTypeAsString() {*
		return this.DSortingType;
	*}
	
	/**
	 * Sets Member Sorting Type Property by Choice Option
	 */	
	void setSortingType( /**Member Sorting Type*/ org_scn_community_shared_SortTypeEnumfield sortingType){*
		this.DSortingType = sortingType;
	*}
	
	/**
	 * Gets Member Sorting Type Property as Choice Option
	 */	
	org_scn_community_shared_SortTypeEnumfield getSortingType() {*
		return this.DSortingType;
	*}

	/**
	 * Sets Zero Values Display Mode Property by String
	 */	
	void setZeroValuesModeByString( /**Zero Values Display Mode*/ String zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}

	/**
	 * Gets Zero Values Display Mode Property as String
	 */	
	String getZeroValuesModeAsString() {*
		return this.DZeroValuesMode;
	*}
	
	/**
	 * Sets Zero Values Display Mode Property by Choice Option
	 */	
	void setZeroValuesMode( /**Zero Values Display Mode*/ org_scn_community_shared_Enumfield zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}
	
	/**
	 * Gets Zero Values Display Mode Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getZeroValuesMode() {*
		return this.DZeroValuesMode;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Reads the Dimensions from Data Source 
	 */
	@Visibility(private)
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Resultset") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.customDimensionsFlat = "|";
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.customDimensionsFlat = l.customDimensionsFlat + l.customDimensions[iD] + "|";
			}
			
			l.dimensions = [];
			
			l.dimensionsAll.forEach(function(dimension, indexD) {
				l.currentAvailableDimensionName = dimension.name; 
				if(l.customDimensionsFlat.indexOf("|" + l.currentAvailableDimensionName + "|") > -1) {
					l.dimensions.push(dimension);
				}
			});	
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}

	/**
	 * Resets the actual data of all dimensions (and causes reload of all members in "reloadDataSource" method.
	 * Use it together like below
	 * <example>
	 * You want to reload actual members again
	 * <code>
	 * FACET.resetDimensions();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 */
	void resetDimensions() {*
		this.oldDimensionKeys = "";
	*}

	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}

	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACET.reloadDataSource();
	 * 
	 * // every time 
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	@Visibility(private)
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.isClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

}

/**
 * Generated ZTL Class for FioriLink
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FioriLink extends org.scn.community.shared.ui5.Link {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for FioriBusyDialog
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FioriBusyDialog extends org.scn.community.shared.ui5.BusyDialog {




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Opens The Dilaog
	 */
	void open() {*
		this.interactionInt = this.interactionInt + 1;
	*}
	
	/**
	 * Closes The Dilaog
	 */
	void close() {*
		this.interactionInt = this.interactionInt - 1;
	*}

}
/**
 * enum field definition
 */
class org_scn_community_shared_ThresholdMethod extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ThresholdMethodTypes extends Enum {

	/** CHECKED */
	org_scn_community_shared_ThresholdMethod CHECKED;
       
	/** UNCHECKED */
	org_scn_community_shared_ThresholdMethod UNCHECKED;

	/** MIXED */
	org_scn_community_shared_ThresholdMethod MIXED;
}


class org.scn.community.databound.HexBin extends org.scn.community.shared.DataComponent {
	/**
	Set Threshold Method
	*/
	void setThresholdMethod(/*Method*/ String method) {*
		this.thresholdMethod = method;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set Max Threshold
	*/
	void setThreshold(/*Threshold*/int threshold) {*
		this.threshold = threshold;
	*}
	/**
	Get Max Threshold
	*/
	int getThreshold() {*
		return this.threshold;
	*}
	/**
	Set Min Threshold (Tolerance)
	*/
	void setTolerance(/*Tolerance*/int tolerance) {*
		this.tolerance = tolerance;
	*}
	/**
	Get Min Threshold (Tolerance)
	*/
	int getTolerance() {*
		return this.tolerance;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Generated ZTL Class for KpiTile
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.KpiTile extends org.scn.community.shared.Component {

	/**
	 * Gets Clicked Component Property
	 */	
	String getClickedComponent() {*
		return this.clickedComponent;
	*}

	/**
	 * Sets Number of Columns Property
	 */	
	void setColumnNumber( /**Number of Columns*/ int columnNumber){*
		this.columnNumber = columnNumber;
	*}

	/**
	 * Gets Number of Columns Property
	 */	
	int getColumnNumber() {*
		return this.columnNumber;
	*}

	/** Adds an element containing parentKey [String], key [String], dimension [String], cast [String], value [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	KPITILE.addProperty(parentKey [String], key [String], dimension [String], cast [String], value [String]);<br>
	KPITILE.addProperty(parentKey [String], key [String], dimension [String], cast [String], value [String]);
	</code>
	</example>
	 */
	void addProperty (
			/**Parent Key*/String parentKey, 
			/**Property Name*/String key, 
			/**Linked Dimension or Measure Key*/String dimension, 
			/**Final Property Type (Cast)*/String cast, 
			/**Property Value*/String value
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			dimension:dimension, 
			cast:cast, 
			value:value 
			};
	
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			this.componentsSpec = "[]";
		}
		
		var elementsJson = JSON.parse(this.componentsSpec);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/** Adds a root element containing key [String], componentType [String], top [int], bottom [int], left [int], right [int], width [int], height [int], specification [String].

 	<example>
	You want to add 2 root elements
	<code>
	KPITILE.addComponent(key [String], componentType [String], top [int], bottom [int], left [int], right [int], width [int], height [int], specification [String]);<br>
	KPITILE.addComponent(key [String], componentType [String], top [int], bottom [int], left [int], right [int], width [int], height [int], specification [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addComponent (
			/**Unique Key*/String key, 
			/**Component Type*/String componentType, 
			/**Top Position (-1 if bottom margin is set)*/int top, 
			/**Bottom Position*/int bottom, 
			/**Left Position (-1 if right margin is set)*/int left, 
			/**Rigth Position*/int right, 
			/**Width in Px*/int width, 
			/**Height in Px*/int height, 
			/**Full Specification*/String specification
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			componentType:componentType, 
			top:top, 
			bottom:bottom, 
			left:left, 
			right:right, 
			width:width, 
			height:height, 
			specification:specification 
			};
	
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			this.componentsSpec = "[]";
		}
		
		var elementsJson = JSON.parse(this.componentsSpec);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	KPITILE.removeProperty(String key);<br>
	</code>
	</example>
	 */
	void removeProperty (
			String key
			) {*		
		
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			this.componentsSpec = "[]";
		}
		
		var elementsJson = JSON.parse(this.componentsSpec);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	KPITILE.removeComponent(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeComponent (
			String key
			) {*		
		
		this.removeProperty(key);
	*}

	/**
	 * Gets Components As JSON String
	 */	
	String getComponentsAsJSON() {*
		var jsonObject = JSON.parse(this.componentsSpec);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Components
	 */	
	String cleanAllComponents() {*
		this.componentsSpec = "[]";
	*}
	/**
	 * Sets the ComponentType for Component keys<br/>
	 */
	void setComponentComponentTypes (
			/**/ String keys,
			/**/ String separator,
	        /* ComponentType */ String componentType
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].componentType = componentType;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ComponentType for Component Key<br/>
	 */
	void setComponentComponentType (
			/**/ String key,
			/**/ String componentType
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].componentType = componentType;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ComponentType for Component Key<br/>
	 */
	String getComponentComponentType (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].componentType;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Top for Component keys<br/>
	 */
	void setComponentTops (
			/**/ String keys,
			/**/ String separator,
	        /* Top */ int top
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].top = top;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Top for Component Key<br/>
	 */
	void setComponentTop (
			/**/ String key,
			/**/ int top
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].top = top;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Top for Component Key<br/>
	 */
	int getComponentTop (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].top;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Bottom for Component keys<br/>
	 */
	void setComponentBottoms (
			/**/ String keys,
			/**/ String separator,
	        /* Bottom */ int bottom
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].bottom = bottom;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Bottom for Component Key<br/>
	 */
	void setComponentBottom (
			/**/ String key,
			/**/ int bottom
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].bottom = bottom;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Bottom for Component Key<br/>
	 */
	int getComponentBottom (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].bottom;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Left for Component keys<br/>
	 */
	void setComponentLefts (
			/**/ String keys,
			/**/ String separator,
	        /* Left */ int left
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].left = left;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Left for Component Key<br/>
	 */
	void setComponentLeft (
			/**/ String key,
			/**/ int left
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].left = left;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Left for Component Key<br/>
	 */
	int getComponentLeft (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].left;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Right for Component keys<br/>
	 */
	void setComponentRights (
			/**/ String keys,
			/**/ String separator,
	        /* Right */ int right
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].right = right;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Right for Component Key<br/>
	 */
	void setComponentRight (
			/**/ String key,
			/**/ int right
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].right = right;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Right for Component Key<br/>
	 */
	int getComponentRight (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].right;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Width for Component keys<br/>
	 */
	void setComponentWidths (
			/**/ String keys,
			/**/ String separator,
	        /* Width */ int width
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].width = width;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Width for Component Key<br/>
	 */
	void setComponentWidth (
			/**/ String key,
			/**/ int width
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].width = width;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Width for Component Key<br/>
	 */
	int getComponentWidth (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].width;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Height for Component keys<br/>
	 */
	void setComponentHeights (
			/**/ String keys,
			/**/ String separator,
	        /* Height */ int height
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].height = height;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Height for Component Key<br/>
	 */
	void setComponentHeight (
			/**/ String key,
			/**/ int height
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].height = height;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Height for Component Key<br/>
	 */
	int getComponentHeight (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].height;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Specification for Component keys<br/>
	 */
	void setComponentSpecifications (
			/**/ String keys,
			/**/ String separator,
	        /* Specification */ String specification
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].specification = specification;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Specification for Component Key<br/>
	 */
	void setComponentSpecification (
			/**/ String key,
			/**/ String specification
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].specification = specification;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Specification for Component Key<br/>
	 */
	String getComponentSpecification (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].specification;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Dimension for Property keys<br/>
	 */
	void setPropertyDimensions (
			/**/ String keys,
			/**/ String separator,
	        /* Dimension */ String dimension
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].dimension = dimension;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Dimension for Property Key<br/>
	 */
	void setPropertyDimension (
			/**/ String key,
			/**/ String dimension
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].dimension = dimension;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Dimension for Property Key<br/>
	 */
	String getPropertyDimension (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].dimension;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Cast for Property keys<br/>
	 */
	void setPropertyCasts (
			/**/ String keys,
			/**/ String separator,
	        /* Cast */ String cast
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].cast = cast;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Cast for Property Key<br/>
	 */
	void setPropertyCast (
			/**/ String key,
			/**/ String cast
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].cast = cast;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Cast for Property Key<br/>
	 */
	String getPropertyCast (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].cast;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Value for Property keys<br/>
	 */
	void setPropertyValues (
			/**/ String keys,
			/**/ String separator,
	        /* Value */ String value
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].value = value;
					break;
				}
			}
		}
		
		this.componentsSpec = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Value for Property Key<br/>
	 */
	void setPropertyValue (
			/**/ String key,
			/**/ String value
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].value = value;
				break;
			}
		}

		this.componentsSpec = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Value for Property Key<br/>
	 */
	String getPropertyValue (
			/**/ String key
			) 
	{*
		if (this.componentsSpec === undefined || this.componentsSpec === "" || this.componentsSpec === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.componentsSpec);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].value;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Content Height Property
	 */	
	void setContentHeight( /**Content Height*/ int contentHeight){*
		this.contentHeight = contentHeight;
	*}

	/**
	 * Gets Content Height Property
	 */	
	int getContentHeight() {*
		return this.contentHeight;
	*}

	/**
	 * Sets Respopnsive Content Property
	 */	
	void setContentResponsive( /**Respopnsive Content*/ boolean contentResponsive){*
		this.contentResponsive = contentResponsive;
	*}

	/**
	 * Gets Respopnsive Content Property
	 */	
	boolean isContentResponsive() {*
		return this.contentResponsive;
	*}

	/**
	 * Sets Result Set Property
	 */	
	void setData( /**Result Set*/ ResultSet data){*
		this.data = data;
	*}

	/**
	 * Gets Result Set Property
	 */	
	ResultSet getData() {*
		return this.data;
	*}







	/**
	 * Gets Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for LeaderBoard
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.LeaderBoard extends org.scn.community.shared.Component {

	/**
	 * Sets Add Counter Property
	 */	
	void setAddCounter( /**Add Counter*/ boolean addCounter){*
		this.addCounter = addCounter;
	*}

	/**
	 * Gets Add Counter Property
	 */	
	boolean isAddCounter() {*
		return this.addCounter;
	*}

	/**
	 * Sets Allow Any Interaction Property
	 */	
	void setAllowInteraction( /**Allow Any Interaction*/ boolean allowInteraction){*
		this.allowInteraction = allowInteraction;
	*}

	/**
	 * Gets Allow Any Interaction Property
	 */	
	boolean isAllowInteraction() {*
		return this.allowInteraction;
	*}



	/**
	 * Sets Url For The Fallback Picture Property
	 */	
	void setFallbackPicture( /**Url For The Fallback Picture*/ String fallbackPicture){*
		this.fallbackPicture = fallbackPicture;
	*}

	/**
	 * Gets Url For The Fallback Picture Property
	 */	
	String getFallbackPicture() {*
		return this.fallbackPicture;
	*}

	/**
	 * Sets Ignore Average Property
	 */	
	void setIgnoreAverage( /**Ignore Average*/ boolean ignoreAverage){*
		this.ignoreAverage = ignoreAverage;
	*}

	/**
	 * Gets Ignore Average Property
	 */	
	boolean isIgnoreAverage() {*
		return this.ignoreAverage;
	*}

	/**
	 * Sets Maximum Number Property
	 */	
	void setMaxNumber( /**Maximum Number*/ int maxNumber){*
		this.maxNumber = maxNumber;
	*}

	/**
	 * Gets Maximum Number Property
	 */	
	int getMaxNumber() {*
		return this.maxNumber;
	*}





	/**
	 * Gets Technical Proprty For Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Gets Technical Proprty For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Top X Or Bottom X Property by String
	 */	
	void setTopBottomByString( /**Top X Or Bottom X*/ String topBottom){*
		this.topBottom = topBottom;
	*}

	/**
	 * Gets Top X Or Bottom X Property as String
	 */	
	String getTopBottomAsString() {*
		return this.topBottom;
	*}
	
	/**
	 * Sets Top X Or Bottom X Property by Choice Option
	 */	
	void setTopBottom( /**Top X Or Bottom X*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.topBottom = topBottom;
	*}
	
	/**
	 * Gets Top X Or Bottom X Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.topBottom;
	*}

	/**
	 * Sets Use Pictures Property
	 */	
	void setUsePictures( /**Use Pictures*/ boolean usePictures){*
		this.usePictures = usePictures;
	*}

	/**
	 * Gets Use Pictures Property
	 */	
	boolean isUsePictures() {*
		return this.usePictures;
	*}

	/**
	 * Sets Value Decimal Places Property by String
	 */	
	void setValueDecimalPlacesByString( /**Value Decimal Places*/ String valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}

	/**
	 * Gets Value Decimal Places Property as String
	 */	
	String getValueDecimalPlacesAsString() {*
		return this.valueDecimalPlaces;
	*}
	
	/**
	 * Sets Value Decimal Places Property by Choice Option
	 */	
	void setValueDecimalPlaces( /**Value Decimal Places*/ org_scn_community_shared_DecimalPlacesEnumfield valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}
	
	/**
	 * Gets Value Decimal Places Property as Choice Option
	 */	
	org_scn_community_shared_DecimalPlacesEnumfield getValueDecimalPlaces() {*
		return this.valueDecimalPlaces;
	*}

	/**
	 * Sets Value Prefix Text Property
	 */	
	void setValuePrefix( /**Value Prefix Text*/ String valuePrefix){*
		this.valuePrefix = valuePrefix;
	*}

	/**
	 * Gets Value Prefix Text Property
	 */	
	String getValuePrefix() {*
		return this.valuePrefix;
	*}

	/**
	 * Sets Value Suffix Text Property
	 */	
	void setValueSuffix( /**Value Suffix Text*/ String valueSuffix){*
		this.valueSuffix = valueSuffix;
	*}

	/**
	 * Gets Value Suffix Text Property
	 */	
	String getValueSuffix() {*
		return this.valueSuffix;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/**
 * Class for Pictogram
 */
class org.scn.community.databound.LeafletMap extends org.scn.community.shared.Component {
	/**
	Debug
	*/
	String setBIAL(/* Debug */ String bial) {*
		return JSON.stringify(eval(bial));
	*}
}
class org.scn.community.databound.LocationIntel extends org.scn.community.shared.Component {
	/**
	Get selected feature
	*/
	String getSelectedMarker() {*
		return this.selectedMarker;
	*}
	/**
	Set Projection Method
	*/
	void setProjection(/*Projection*/String projection) {*
		this.projection = projection;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Marker Color
	*/
	void setMarkerColor(/*Color*/String color) {*
		this.markerColor = color;
	*}
	/**
	Set Marker Title Field
	*/
	void setMarkerTitle(/*Color*/String dimension) {*
		this.markerTitle = dimension;
	*}
	/**
	Set Marker Size Field
	*/
	void setMarkerSizeMeasure(/*Color*/String measure) {*
		this.markerSizeMeasure = measure;
	*}
	/**
	Set Label Attribute from GeoJSON that should be used for labeling
	*/
	void setLabelProperty(/*Attribute*/String attribute) {*
		this.labelProperty = attribute;
	*}
}
class org.scn.community.databound.MarimekkoChart extends org.scn.community.shared.DataComponent {
	/**
	Get selected row
	*/
	String getSelectedRow() {*
		return this.selectedRow;
	*}
	/**
	Get selected column
	*/
	String getSelectedColumn() {*
		return this.selectedColumn;
	*}
	/**
	Get selected value
	*/
	float getSelectedValue() {*
		return this.selectedValue;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
}

/**
 * Class for MultiComboBox
 */
class org.scn.community.databound.MultiComboBox extends org.scn.community.shared.DataComponent {

	/** gest the dimension */
	boolean getEnabled () {*
		return this.DEnabled;	
	*}
	
	/** sets the dimension */
	void setEnabled (boolean enabled) {*
		this.DEnabled = enabled;	
	*}
	
	/** returns the selected key 
    <example>
	
	<code>
    
	</code>
	</example>
	*/
	String getSelectedKey () {*
		return this.DSelectedKey;	
	*}
	/** Clear selection 
    <example>
	
	<code>
    
	</code>
	</example>
	*/
	String clearSelection () {*
		this.DSelectedKey = "";
		this.DSelectedText = "";
		this.DSelectedKeyBexReady = "";
	*}
	/** returns the selected key 
    <example>
	
	<code>
    
	</code>
	</example>
	*/
	String getSelectedKeyBexReady () {*
		return this.DSelectedKeyBexReady;	
	*}

	/** returns the selected text */
	String getSelectedText () {*
		return this.DSelectedText;	
	*}
	
	/** gets the dimension */
	String getDimension () {*
		return this.DDimension;	
	*}
	
	/** sets the dimension */
	void setDimension (String dimension) {*
		this.DDimension = dimension;	
	*}
	/**
	 * Set to true to enable Ascending sorting, false for the opposite
	 */
	void setSortingDirection (boolean direction) {* 
		if(direction){
			this.DSortingDirection = "Ascending";	
		}else{
			this.DSortingDirection = "Descending";
		}
	*}
	/**
	 * 
	 */
	void setSkipResult (boolean skip) {* 
		this.DSkipResultRow = skip;
	*}
	
	void setItems (String itemList) {*
		this.DItemList = itemList;
	*}
	
}
class org.scn.community.databound.MultiLevelDropDown extends Component {
	
	/**
	 * Returns the value of addSingleNode (boolean).
	 */
	boolean isSingleNodeActivated() {*
		return this.addSingleRootNode;
	*}

	/**
	 * Changes the addSingleNode (boolean).<br>
	 * Instead of having all of the first nodes displayed directly in the menu, a new root node will be added
	 */
	void setAddSingleRootNode(Boolean value) {*
		this.addSingleRootNode = value;
	*}
	
	/** 
	 * Returns the name of the generated root node 
	 */
	String getSingleRootNodeName() {*
		return this.singleRootNodeName;
	*}

	/** 
	 * Set the name of the generated root node 
	 */
	void setSingleRootNodeName(String newName) {*
		this.singleRootNodeName = newName;
	*}
	
	/** 
	 * Returns the selected hierarchy key in the menu.
	 * You can directly use this value in a setFilter on the dimension displayed as hierarchy.
	 */
	String getSelectedElemKey() {*
		return this.SelectedElemKey;
	*}
	
	/** 
	 * Simulates a click on a node by the user.<br>
	 * The node will be selected and the event "onClick" will be triggered.
	 */
	void setSelectedElemKey(String selectedKey) {*
		this.SelectedElemKey = selectedKey;
	*}
	
	/** 
	 * Returns the value of the property LabelDisplay
	 */
	String getLabelDisplay() {*
		return this.labelDisplay;
	*}

	/** 
	 * Set the value of the property LabelDisplay (Case-sensitive). It is all depending on how your hierarchy is displayed: Key, Text, Text+Key ...
	 * <br>Available values:
	 * <example>
	 * <code>
	 * "key":"HIERARCHY_NODE/0HIER_NODE/EUROPE","level":0,"text":"Europe|EUROPE"
	 * </code>
	 * The previous hierarchy node is displayed as Text+Key.<br>
	 * You can use values from: <br>
	 * - NodeKey: HIERARCHY_NODE/0HIER_NODE/EUROPE (internal hierarchy node key, can be using in setFilter and setVariables calls)<br>
	 * - Left: Europe<br>
	 * - Right: EUROPE (External Key)<br>
	 * </example>
	 */
	void setLabelDisplay(String value) {*
		this.labelDisplay = value;
	*}
	
	/** ------- Getter / Setter for selectedElemKey ------ */
	String getSelectedElemText() {*
		return this.SelectedElemText;
	*}
	
	/** get the state of the reset button (Left, Right, No) */
	String getResetButton() {*
		return this.resetButton;
	*}
	
	/** 
	 * Set the value of the property LabelDisplay (Case-sensitive). It is all depending on how your hierarchy is displayed: Key, Text, Text+Key ...
	 * Available values:<br>
	 * - Left<br>
	 * - Right<br>
	 * - None
	 */
	void setResetButton(String value) {*
		this.resetButton = value;
	*}

	/** Get the technical name of the dimension with the hierarchy */
	String getDimension() {*
		return this.selChar;
	*}

	/** 
	 * Change the dimension with the hierarchy. OnLoadReady will be called.
	 */
	void setDimension(String value) {*
		this.selChar = value;
	*}
	
	/**
	 * Return true/false if a measure should be displayed in the menu.<br>
	 * If no measure has been selected, it has no effect.
	  */
	boolean isMeasureDisplayActivated() {*
		return this.addMesure;
	*}

	/** 
	 * Activate the display of the measure in the menu.<br>
	 * If no measure has been selected, it has no effect.
	 */
	void activateDisplayMeasure(Boolean value) {*
		this.addMesure = value;
	*}
	
	/** 
	 * Hide the menu. Kinda a Utility mode for the hierarchy members accessor
	 */
	void hideMenu(Boolean value) {*
		this.hideMenu = value;
	*}
	
	/** return the technical name of the selected measure */
	String getSelMeasure() {*
		return this.selMesure;
	*}

	/**
	 * Set the measure that should be displayed in the menu.<br>
	 * The measure display should be active before (you can use method activateDisplayMeasure())
	 */
	void setSelMeasure(String value) {*
		this.selMesure = value;
	*}
	
	/** return the JSON corresponding to the color classes */
	String getColorClass() {*
		return this.colorClass;
	*}

	/**
	 * Pass rules that will apply cssClass to the elements.
	 * Format: [  {"cssClass":"Name of the CSS class to apply", "low":"from value, numeric", "high":"to value, numeric"} ]<br>
	 * High value is excluded.
	 * <example>
	 * <code>[<br>
	 * {"cssClass":"DD_RED", "low":"0", "high":"10"},<br> 
     * {"cssClass":"DD_YEL", "low":"10", "high":"40"},<br>
     * {"cssClass":"DD_GREEN","low":"40", "high":"100"}<br> 
     * ]</code>
     * </example>
	 */
	void setColorClass(String value) {*
		this.colorClass = value;
	*}
	
	/** Get the replacement text set instead of the not assigned node. Empty means not replaced */
	String getNotAssignedText() {*
		return this.notAssignedText;
	*}

	/** Set the replacement text set instead of the not assigned node. Empty means not replaced */
	void setNotAssignedText(String value) {*
		this.notAssignedText = value;
	*}
	
	/** Return all the hierarchy members as a JSON object. */
	String getHierarchyMembersAsJsonString() {*
		return JSON.stringify(this.getHierarchyMembers());
	*}
	
	/* Return the hierarchy members in the native DS format (JSON) */
	String getHierarchyMembersSource() {*
		return this.jsonDimensionHierMembers;
	*}
	
	/**
	 * Return an array with all the hierarchy members. Array support forEach()
	 * Elements are typed and you can access attributes like:
	 * - ID: integer, internal ID<br>
	 * - <strong>key</strong>: hierarchy node key. Can be used in a setFilter or setVariable method call<br>
	 * - <strong>text</strong>: text of the node. Format depends on the hierarchy display.<br>
	 *   If text+key, text will contains "text|key". If just text, you'll get only the text.<br>
	 * - <strong>Level</strong>: Depth of the node/leaf, starts at 0<br>
	 * - <strong>Type</strong>: infoobject type: HIERARCHY_NODE or technical name of the infoobject<br>
	 * - <strong>parentID</strong>: parent internal ID<br>
	 * - <strong>parentKey</strong>: Hierarchy node key, BW value. Can be used by setFilter etc.<br>
	 * - <strong>isLeaf</strong>: true or false<br>
	 * - <strong>nodeState</strong>: COLLAPSED / EXPANDED for nodes or leaf for leafs.<br>
	 */
	org.scn.community.shared.HierarchyMemberArray getHierarchyMembers() {*
		var content 		= [];
		var lifoParents		= [];
		var previousMember	= {};
		
		//nothing in the jsonString.
		if (this.jsonDimensionHierMembers == "") {
			return content;
		}
		
		//Parse the Json Array
		var dimension 		= JSON.parse(this.jsonDimensionHierMembers);
		
		var lastLevel 		= 0;
		
		for(var i=0;i<dimension.members.length; i++ ){
			var hierMember 		= {};
			var member 			= dimension.members[i];
			
			hierMember.key 		= 0;
					
			if (member.hasOwnProperty('level'))
				hierMember.level = member.level;
			else {
				hierMember.level = 0;
			}
			
			hierMember.key 				= member.key;
			hierMember.text 			= member.text;
			hierMember.ID 				= i;
			
			if (member.hasOwnProperty('parent') && i > 0) {
				hierMember.parentKey 	= member.parent;
				hierMember.parentID 	= content [i-1].ID;
			} else {
				hierMember.parentKey 	= "";
				hierMember.parentID 	= -1;
			}
			
			if (member.hasOwnProperty('type'))
					hierMember.type 	= member.type;
			else 	hierMember.type		= dimension.key;
			
			if (member.hasOwnProperty('nodeState'))
					hierMember.nodeState = member.nodeState;
			else 	hierMember.nodeState = "leaf";	
			
			hierMember.isLeaf 			= !member.hasOwnProperty('nodeState');

			content.push(hierMember);
		}
		
		return content;
	*}
}

/**
 * Generated ZTL Class for NiceChart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.NiceChart extends org.scn.community.shared.Component {

	/**
	 * Sets Chart Type Property by String
	 */	
	void setChartTypeByString( /**Chart Type*/ String chartType){*
		this.DChartType = chartType;
	*}

	/**
	 * Gets Chart Type Property as String
	 */	
	String getChartTypeAsString() {*
		return this.DChartType;
	*}
	
	/**
	 * Sets Chart Type Property by Choice Option
	 */	
	void setChartType( /**Chart Type*/ org_scn_community_shared_ChartSimpleTypeEnumfield chartType){*
		this.DChartType = chartType;
	*}
	
	/**
	 * Gets Chart Type Property as Choice Option
	 */	
	org_scn_community_shared_ChartSimpleTypeEnumfield getChartType() {*
		return this.DChartType;
	*}

	/**
	 * Sets Starting Colour Distance Property
	 */	
	void setColorDistance( /**Starting Colour Distance*/ float colorDistance){*
		this.DColorDistance = colorDistance;
	*}

	/**
	 * Gets Starting Colour Distance Property
	 */	
	float getColorDistance() {*
		return this.DColorDistance;
	*}

	/**
	 * Sets Starting Colour Hue Property
	 */	
	void setColorHue( /**Starting Colour Hue*/ int colorHue){*
		this.DColorHue = colorHue;
	*}

	/**
	 * Gets Starting Colour Hue Property
	 */	
	int getColorHue() {*
		return this.DColorHue;
	*}

	/**
	 * Sets Starting Colour Palette Property by String
	 */	
	void setColorPaletteByString( /**Starting Colour Palette*/ String colorPalette){*
		this.DColorPalette = colorPalette;
	*}

	/**
	 * Gets Starting Colour Palette Property as String
	 */	
	String getColorPaletteAsString() {*
		return this.DColorPalette;
	*}
	
	/**
	 * Sets Starting Colour Palette Property by Choice Option
	 */	
	void setColorPalette( /**Starting Colour Palette*/ org_scn_community_shared_ChartColorPaleteEnumfield colorPalette){*
		this.DColorPalette = colorPalette;
	*}
	
	/**
	 * Gets Starting Colour Palette Property as Choice Option
	 */	
	org_scn_community_shared_ChartColorPaleteEnumfield getColorPalette() {*
		return this.DColorPalette;
	*}

	/**
	 * Sets Legend Position Property by String
	 */	
	void setLegendPositionByString( /**Legend Position*/ String legendPosition){*
		this.DLegendPosition = legendPosition;
	*}

	/**
	 * Gets Legend Position Property as String
	 */	
	String getLegendPositionAsString() {*
		return this.DLegendPosition;
	*}
	
	/**
	 * Sets Legend Position Property by Choice Option
	 */	
	void setLegendPosition( /**Legend Position*/ org_scn_community_shared_HorizontalAlignEnumfield legendPosition){*
		this.DLegendPosition = legendPosition;
	*}
	
	/**
	 * Gets Legend Position Property as Choice Option
	 */	
	org_scn_community_shared_HorizontalAlignEnumfield getLegendPosition() {*
		return this.DLegendPosition;
	*}

	/**
	 * Sets Width Of Legend In Px Property
	 */	
	void setLegendWidth( /**Width Of Legend In Px*/ int legendWidth){*
		this.DLegendWidth = legendWidth;
	*}

	/**
	 * Gets Width Of Legend In Px Property
	 */	
	int getLegendWidth() {*
		return this.DLegendWidth;
	*}

	/**
	 * Sets Maximum Number Of Data Points Property
	 */	
	void setMaxDataPoints( /**Maximum Number Of Data Points*/ int maxDataPoints){*
		this.DMaxDataPoints = maxDataPoints;
	*}

	/**
	 * Gets Maximum Number Of Data Points Property
	 */	
	int getMaxDataPoints() {*
		return this.DMaxDataPoints;
	*}

	/**
	 * Sets Show Legend Property
	 */	
	void setShowLegend( /**Show Legend*/ boolean showLegend){*
		this.DShowLegend = showLegend;
	*}

	/**
	 * Gets Show Legend Property
	 */	
	boolean isShowLegend() {*
		return this.DShowLegend;
	*}

	/**
	 * Sets Swap Axes Property
	 */	
	void setSwapAxes( /**Swap Axes*/ boolean swapAxes){*
		this.DSwapAxes = swapAxes;
	*}

	/**
	 * Gets Swap Axes Property
	 */	
	boolean isSwapAxes() {*
		return this.DSwapAxes;
	*}

	/**
	 * Sets Result Set Property
	 */	
	void setData( /**Result Set*/ ResultSet data){*
		this.data = data;
	*}

	/**
	 * Gets Result Set Property
	 */	
	ResultSet getData() {*
		return this.data;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/**
 * Class for Pictogram
 */
class org.scn.community.databound.Pictogram extends org.scn.community.shared.Component {
	/**
	Sets number of columns
	*/
	void setNumCols(/* Number of Columns */ int columns) {*
		this.numCols = columns;
	*}
	/**
	Sets number of rows
	*/
	void setNumRows(/* Number of Rows */ int rows) {*
		this.numRows = rows;
	*}
	/**
	Gets number of columns
	*/
	int getNumCols() {* return this.numCols; *}
	/**
	Gets number of rows
	*/
	int getNumCols() {* return this.numRows; *}
}

/**
 * Generated ZTL Class for PlanningCalendar
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.PlanningCalendar extends org.scn.community.shared.ui5.PlanningCalendar {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for ProcessFlow
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.ProcessFlow extends org.scn.community.shared.ui5.ProcessFlow {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/**
 * Class for ProgressBar Properties
 */
class org.scn.community.databound.BarProperty {
  String title;
  String fillColor;
  String number;
  String numberUnit;
}

/**
 * Class for ProgressBar
 */
class org.scn.community.databound.ProgressSet extends org.scn.community.shared.Component {
	/**
	Sets bar thickness (-1 = auto)
	*/
	void setBarThickness(/* Thickness */ int thickness) {*
		this.barHeight = thickness;
	*}
	/**
	Gets bar thickness (-1 = auto)
	*/
	int getBarThickness() {*
		return this.barHeight;
	*}
	/**
	Sets inline labels to true/false
	*/
	void setInlineLabels(/* true/false */ boolean isInline) {*
		this.inlineLabels = isInline;
	*}
	/**
	Gets whether labels are inline are not
	*/
	boolean getInlineLabels() {*
		return this.inlineLabels;
	*}
	/**
	Gets Bar Selected
	*/
	String getBarClicked() {*
		return this.selectedBar;
	*}
	/** Remove All Bars
 	<example>
	Remove all bars
	<code>
	PROGRESSET_1.removeAllBars();<br>
	</code>
	</example>
	 */
	void removeAllBars () {*		
		this.barConfig = JSON.stringify([]);
	*}
	/** Remove a bar
 	<example>
	Remove a bar titled "Sales"
	<code>
	PROGRESSET_1.removeBar("Sales");<br>
	</code>
	</example>
	 */
	void removeBar (/*Tile Title*/String title) {*		
		var o = eval(this.barConfig);
		if(!o) o = [];
		var matchIndex = -1;
		for(var i=0;i<o.length;i++){
			if(o[i].title == title) matchIndex = i;
		}
		if(matchIndex>-1) o.splice(matchIndex,1);
		barConfig = JSON.stringify(o);
	*}
	com.sample.utilities.BarProperty getBarProperty(/*Title*/String title){*
		var r = {
			title : "",
			fillColor : "",
			number : "",
			numberUnit : ""
		}
		var o = eval(this.barConfig);
		var matchIndex = -1;
		for(var i=0;i<o.length;i++){
			if(o[i].title == title) matchIndex = i;
		}
		if(matchIndex>-1){
			var barConf = o[matchIndex];
			r.title = barConf.title;
			r.fillColor = barConf.fillColor;
			r.number = tileConf.number;
			r.numberUnit = tileConf.numberUnit;
		}
		return r;
	*}
	/** Adds or Updates a Bar (if title already exists)
 	<example>
	Add/Update a bar called "Sales"
	<code>
	PROGRESSET_1.addBar("Sales", "#FF0000", "1234", "USD");<br>
	</code>
	</example>
	 */
	void addBar (
			/*Title*/String title, 
			/*Number*/optional String number, 
			/*Number Unit*/optional String numberUnit,
			/*Fill Color*/optional String fillColor
			) {*		
		var o = eval(this.barConfig);
		if(!o) o = [];
		var bar = {
			title: title,
			fillColor: fillColor || "auto",
			number: number,
			numberUnit: numberUnit
		};	
		var matchIndex = -1;
		for(var i=0;i<o.length;i++){
			if(o[i].title == title) matchIndex = i;
		}
		if(matchIndex==-1){	// New Bar
			o.push(bar);
		}else{	// Update Bar
			o[matchIndex] = bar;
		}
		barConfig = JSON.stringify(o);
	*}
}

/**
 * Generated ZTL Class for RadioButtonGroup
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.RadioButtonGroup extends org.scn.community.shared.ui5.RadioButtonGroup {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for RangeSlider
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.RangeSlider extends org.scn.community.shared.Component {



	/**
	 * Gets Technical Proprty For Pause Refresh Property
	 */	
	boolean isDoRefresh() {*
		return this.doRefresh;
	*}

	/**
	 * Sets Maximum Number Property
	 */	
	void setMaxNumber( /**Maximum Number*/ int maxNumber){*
		this.maxNumber = maxNumber;
	*}

	/**
	 * Gets Maximum Number Property
	 */	
	int getMaxNumber() {*
		return this.maxNumber;
	*}





	/**
	 * Gets Technical Proprty For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Gets Technical Proprty For Selected Key 2 Property
	 */	
	String getSelectedKey2() {*
		return this.selectedKey2;
	*}

	/**
	 * Gets Technical Proprty For Selected Keys Property
	 */	
	String getSelectedKeys() {*
		return this.selectedKeys;
	*}

	/**
	 * Gets Technical Proprty For Selected Text Property
	 */	
	String getSelectedText() {*
		return this.selectedText;
	*}

	/**
	 * Gets Technical Proprty For Selected Text 2 Property
	 */	
	String getSelectedText2() {*
		return this.selectedText2;
	*}

	/**
	 * Sets Sorting By Value | Defalut Property by String
	 */	
	void setSortingByString( /**Sorting By Value | Defalut*/ String sorting){*
		this.sorting = sorting;
	*}

	/**
	 * Gets Sorting By Value | Defalut Property as String
	 */	
	String getSortingAsString() {*
		return this.sorting;
	*}
	
	/**
	 * Sets Sorting By Value | Defalut Property by Choice Option
	 */	
	void setSorting( /**Sorting By Value | Defalut*/ org_scn_community_shared_Enumfield sorting){*
		this.sorting = sorting;
	*}
	
	/**
	 * Gets Sorting By Value | Defalut Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getSorting() {*
		return this.sorting;
	*}

	/**
	 * Sets Top X, Bottom X Or Both Property by String
	 */	
	void setTopBottomByString( /**Top X, Bottom X Or Both*/ String topBottom){*
		this.topBottom = topBottom;
	*}

	/**
	 * Gets Top X, Bottom X Or Both Property as String
	 */	
	String getTopBottomAsString() {*
		return this.topBottom;
	*}
	
	/**
	 * Sets Top X, Bottom X Or Both Property by Choice Option
	 */	
	void setTopBottom( /**Top X, Bottom X Or Both*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.topBottom = topBottom;
	*}
	
	/**
	 * Gets Top X, Bottom X Or Both Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.topBottom;
	*}

	/**
	 * Sets Change To Vertical Orientation Property
	 */	
	void setVertical( /**Change To Vertical Orientation*/ boolean vertical){*
		this.vertical = vertical;
	*}

	/**
	 * Gets Change To Vertical Orientation Property
	 */	
	boolean isVertical() {*
		return this.vertical;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for ResultSetInfo
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.ResultSetInfo extends org.scn.community.shared.Component {

	/**
	 * Sets Central Data Provisioning Property
	 */	
	void setCentralProvisioning( /**Central Data Provisioning*/ boolean centralProvisioning){*
		this.DCentralProvisioning = centralProvisioning;
	*}

	/**
	 * Gets Central Data Provisioning Property
	 */	
	boolean isCentralProvisioning() {*
		return this.DCentralProvisioning;
	*}

	/**
	 * Gets Technical Component For Data Information Property
	 */	
	String getDataInformation() {*
		return this.DDataInformation;
	*}

	/**
	 * Sets Ignore Results Rows And Columns Property
	 */	
	void setIgnoreResults( /**Ignore Results Rows And Columns*/ boolean ignoreResults){*
		this.DIgnoreResults = ignoreResults;
	*}

	/**
	 * Gets Ignore Results Rows And Columns Property
	 */	
	boolean isIgnoreResults() {*
		return this.DIgnoreResults;
	*}

	/**
	 * Sets Information Event Active Property
	 */	
	void setInformationEventActive( /**Information Event Active*/ boolean informationEventActive){*
		this.DInformationEventActive = informationEventActive;
	*}

	/**
	 * Gets Information Event Active Property
	 */	
	boolean isInformationEventActive() {*
		return this.DInformationEventActive;
	*}

	/**
	 * Sets Result Set Property
	 */	
	void setData( /**Result Set*/ ResultSet data){*
		this.data = data;
	*}

	/**
	 * Gets Result Set Property
	 */	
	ResultSet getData() {*
		return this.data;
	*}




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/** Returns the information about number of cells */
	int getDataInfoNumberOfCells () {*
		return JSON.parse(this.DDataInformation).dataCells;
	*}

	/** Returns the information about number of data columns */
	int getDataInfoNumberOfDataColumns () {*
		return JSON.parse(this.DDataInformation).dataColumns;
	*}
	
	/** Returns the information about number of header columns */
	int getDataInfoNumberOfHeaderColumns () {*
		return JSON.parse(this.DDataInformation).headerColumns;
	*}
	
	/** Returns the information about number of rows */
	int getDataInfoNumberOfRows () {*
		return JSON.parse(this.DDataInformation).rows;
	*}
}

/**
 * Generated ZTL Class for ResultSetMixer
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.ResultSetMixer extends org.scn.community.shared.Component {

	/**
	 * Sets Collect Multiple Matches Property by String
	 */	
	void setCollectMultipleMatchesByString( /**Collect Multiple Matches*/ String collectMultipleMatches){*
		this.DCollectMultipleMatches = collectMultipleMatches;
	*}

	/**
	 * Gets Collect Multiple Matches Property as String
	 */	
	String getCollectMultipleMatchesAsString() {*
		return this.DCollectMultipleMatches;
	*}
	
	/**
	 * Sets Collect Multiple Matches Property by Choice Option
	 */	
	void setCollectMultipleMatches( /**Collect Multiple Matches*/ org_scn_community_shared_Enumfield collectMultipleMatches){*
		this.DCollectMultipleMatches = collectMultipleMatches;
	*}
	
	/**
	 * Gets Collect Multiple Matches Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getCollectMultipleMatches() {*
		return this.DCollectMultipleMatches;
	*}

	/**
	 * Sets Geometry Of The Master Result Set Property by String
	 */	
	void setMasterGeometryByString( /**Geometry Of The Master Result Set*/ String masterGeometry){*
		this.DMasterGeometry = masterGeometry;
	*}

	/**
	 * Gets Geometry Of The Master Result Set Property as String
	 */	
	String getMasterGeometryAsString() {*
		return this.DMasterGeometry;
	*}
	
	/**
	 * Sets Geometry Of The Master Result Set Property by Choice Option
	 */	
	void setMasterGeometry( /**Geometry Of The Master Result Set*/ org_scn_community_shared_Enumfield masterGeometry){*
		this.DMasterGeometry = masterGeometry;
	*}
	
	/**
	 * Gets Geometry Of The Master Result Set Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getMasterGeometry() {*
		return this.DMasterGeometry;
	*}

	/**
	 * Sets Master Central Data Provisioner Property
	 */	
	void setMasterProvisioner( /**Master Central Data Provisioner*/ String masterProvisioner){*
		this.DMasterProvisioner = masterProvisioner;
	*}

	/**
	 * Gets Master Central Data Provisioner Property
	 */	
	String getMasterProvisioner() {*
		return this.DMasterProvisioner;
	*}

	/**
	 * Sets Internal Property To Trigger The Reload Property
	 */	
	void setReloadTrigger( /**Internal Property To Trigger The Reload*/ float reloadTrigger){*
		this.DReloadTrigger = reloadTrigger;
	*}

	/**
	 * Gets Internal Property To Trigger The Reload Property
	 */	
	float getReloadTrigger() {*
		return this.DReloadTrigger;
	*}

	/**
	 * Sets Column Condition To Read Slave Result Set Property
	 */	
	void setSlaveColumnCondition( /**Column Condition To Read Slave Result Set*/ String slaveColumnCondition){*
		this.DSlaveColumnCondition = slaveColumnCondition;
	*}

	/**
	 * Gets Column Condition To Read Slave Result Set Property
	 */	
	String getSlaveColumnCondition() {*
		return this.DSlaveColumnCondition;
	*}

	/**
	 * Sets Column Index For The Selection From Slave Result Set Property
	 */	
	void setSlaveColumnIndex( /**Column Index For The Selection From Slave Result Set*/ int slaveColumnIndex){*
		this.DSlaveColumnIndex = slaveColumnIndex;
	*}

	/**
	 * Gets Column Index For The Selection From Slave Result Set Property
	 */	
	int getSlaveColumnIndex() {*
		return this.DSlaveColumnIndex;
	*}

	/**
	 * Sets Content Condition To Read Slave Result Set Property
	 */	
	void setSlaveContentCondition( /**Content Condition To Read Slave Result Set*/ String slaveContentCondition){*
		this.DSlaveContentCondition = slaveContentCondition;
	*}

	/**
	 * Gets Content Condition To Read Slave Result Set Property
	 */	
	String getSlaveContentCondition() {*
		return this.DSlaveContentCondition;
	*}

	/**
	 * Sets Slave Central Data Provisioner Property
	 */	
	void setSlaveProvisioner( /**Slave Central Data Provisioner*/ String slaveProvisioner){*
		this.DSlaveProvisioner = slaveProvisioner;
	*}

	/**
	 * Gets Slave Central Data Provisioner Property
	 */	
	String getSlaveProvisioner() {*
		return this.DSlaveProvisioner;
	*}

	/**
	 * Sets Row Condition To Read Slave Result Set Property
	 */	
	void setSlaveRowCondition( /**Row Condition To Read Slave Result Set*/ String slaveRowCondition){*
		this.DSlaveRowCondition = slaveRowCondition;
	*}

	/**
	 * Gets Row Condition To Read Slave Result Set Property
	 */	
	String getSlaveRowCondition() {*
		return this.DSlaveRowCondition;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

class org.scn.community.databound.ScatterPlot extends org.scn.community.shared.DataComponent {
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Generated ZTL Class for SideNavigation
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.SideNavigation extends org.scn.community.shared.ui5.SideNavigation {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for Slider
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.Slider extends org.scn.community.shared.Component {



	/**
	 * Gets Technical Proprty For Pause Refresh Property
	 */	
	boolean isDoRefresh() {*
		return this.doRefresh;
	*}

	/**
	 * Sets Maximum Number Property
	 */	
	void setMaxNumber( /**Maximum Number*/ int maxNumber){*
		this.maxNumber = maxNumber;
	*}

	/**
	 * Gets Maximum Number Property
	 */	
	int getMaxNumber() {*
		return this.maxNumber;
	*}





	/**
	 * Gets Technical Proprty For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Gets Technical Proprty For Selected Text Property
	 */	
	String getSelectedText() {*
		return this.selectedText;
	*}

	/**
	 * Sets Sorting By Value | Defalut Property by String
	 */	
	void setSortingByString( /**Sorting By Value | Defalut*/ String sorting){*
		this.sorting = sorting;
	*}

	/**
	 * Gets Sorting By Value | Defalut Property as String
	 */	
	String getSortingAsString() {*
		return this.sorting;
	*}
	
	/**
	 * Sets Sorting By Value | Defalut Property by Choice Option
	 */	
	void setSorting( /**Sorting By Value | Defalut*/ org_scn_community_shared_Enumfield sorting){*
		this.sorting = sorting;
	*}
	
	/**
	 * Gets Sorting By Value | Defalut Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getSorting() {*
		return this.sorting;
	*}

	/**
	 * Sets Top X, Bottom X Or Both Property by String
	 */	
	void setTopBottomByString( /**Top X, Bottom X Or Both*/ String topBottom){*
		this.topBottom = topBottom;
	*}

	/**
	 * Gets Top X, Bottom X Or Both Property as String
	 */	
	String getTopBottomAsString() {*
		return this.topBottom;
	*}
	
	/**
	 * Sets Top X, Bottom X Or Both Property by Choice Option
	 */	
	void setTopBottom( /**Top X, Bottom X Or Both*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.topBottom = topBottom;
	*}
	
	/**
	 * Gets Top X, Bottom X Or Both Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.topBottom;
	*}

	/**
	 * Sets Change To Vertical Orientation Property
	 */	
	void setVertical( /**Change To Vertical Orientation*/ boolean vertical){*
		this.vertical = vertical;
	*}

	/**
	 * Gets Change To Vertical Orientation Property
	 */	
	boolean isVertical() {*
		return this.vertical;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for Table
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.Table extends org.scn.community.shared.Component {

	/**
	 * Sets Column 1 Property
	 */	
	void setColumn1( /**Column 1*/ ResultCellList column1){*
		this.column1 = column1;
	*}

	/**
	 * Gets Column 1 Property
	 */	
	ResultCellList getColumn1() {*
		return this.column1;
	*}

	/**
	 * Sets Column 2 Property
	 */	
	void setColumn2( /**Column 2*/ ResultCellList column2){*
		this.column2 = column2;
	*}

	/**
	 * Gets Column 2 Property
	 */	
	ResultCellList getColumn2() {*
		return this.column2;
	*}

	/**
	 * Sets Column 3 Property
	 */	
	void setColumn3( /**Column 3*/ ResultCellList column3){*
		this.column3 = column3;
	*}

	/**
	 * Gets Column 3 Property
	 */	
	ResultCellList getColumn3() {*
		return this.column3;
	*}




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Class for Tag Cloud
 */

class org.scn.community.databound.tagCloud extends org.scn.community.shared.DataComponent {

/* Returns the Key of the currently selected Tree Element. */
	String getSelectedNodeKey() {*
		return this.selectedNode;
	*}
	
}

/**
 * Class for TileContainer
 */
class org.scn.community.databound.TileContainer extends org.scn.community.shared.DataComponent {

	/**
	 * Set the used tile type 
	 * <example>
	 * 	<code>
	 * 		TC.setTileType("Standard");
	 * 	</code><br>
	 * </example>
	 * Possible values are "Standard" and "Custom"
	 */
	void setTileType(String type){*
		this.DTileType = type;
	*}
	/**
	 * Get current tile type of tilecontainer
	 */
	String getTileType(){*
		return this.DTileType;
	*}
	/**
	 * Get current tile header
	 */
	String getCurrentHeader(){*
		return this.DCurrentHeader;
	*}
	/**
	 * Get current tile footer
	 */
	String getCurrentFooter(){*
		return this.DCurrentFooter;
	*}
	/**
	 * Get current tile value
	 */
	float getCurrentValue(){*
		return this.DCurrentValue;
	*}
	/**
	 * Get current tile value
	 */
	String getCurrentValueText(){*
		return this.DCurrentValueText;
	*}
	/**
	 * Get current tile unit
	 */
	String getCurrentUnit(){*
		return this.DCurrentUnit;
	*}
	/**
	 * Get current tile icon string
	 */
	String getCurrentIconString(){*
		return this.DCurrentIconString;
	*}
	
	@Visibility(private)
	/**
	 *	Workaround for strange DesignStudio lifecycle handling when calling functions via scriptting triggers
	 */
	String calcTimestamp() {*
		return new Date().valueOf();
	*}
}

/**
 * Generated ZTL Class for TopFlop
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.TopFlop extends org.scn.community.shared.Component {

	/**
	 * Sets Add Counter Property
	 */	
	void setAddCounter( /**Add Counter*/ boolean addCounter){*
		this.addCounter = addCounter;
	*}

	/**
	 * Gets Add Counter Property
	 */	
	boolean isAddCounter() {*
		return this.addCounter;
	*}

	/**
	 * Sets Allow Any Interaction Property
	 */	
	void setAllowInteraction( /**Allow Any Interaction*/ boolean allowInteraction){*
		this.allowInteraction = allowInteraction;
	*}

	/**
	 * Gets Allow Any Interaction Property
	 */	
	boolean isAllowInteraction() {*
		return this.allowInteraction;
	*}

	/**
	 * Sets Prefix For Average Value Property
	 */	
	void setAveragePrefix( /**Prefix For Average Value*/ String averagePrefix){*
		this.averagePrefix = averagePrefix;
	*}

	/**
	 * Gets Prefix For Average Value Property
	 */	
	String getAveragePrefix() {*
		return this.averagePrefix;
	*}

	/**
	 * Sets Suffix For Average Value Property
	 */	
	void setAverageSuffix( /**Suffix For Average Value*/ String averageSuffix){*
		this.averageSuffix = averageSuffix;
	*}

	/**
	 * Gets Suffix For Average Value Property
	 */	
	String getAverageSuffix() {*
		return this.averageSuffix;
	*}



	/**
	 * Sets Delta Value Suffix Text Property
	 */	
	void setDeltaValueSuffix( /**Delta Value Suffix Text*/ String deltaValueSuffix){*
		this.deltaValueSuffix = deltaValueSuffix;
	*}

	/**
	 * Gets Delta Value Suffix Text Property
	 */	
	String getDeltaValueSuffix() {*
		return this.deltaValueSuffix;
	*}

	/**
	 * Sets Url For The Fallback Picture Property
	 */	
	void setFallbackPicture( /**Url For The Fallback Picture*/ String fallbackPicture){*
		this.fallbackPicture = fallbackPicture;
	*}

	/**
	 * Gets Url For The Fallback Picture Property
	 */	
	String getFallbackPicture() {*
		return this.fallbackPicture;
	*}

	/**
	 * Sets Fixed Average Value Property
	 */	
	void setFixedAverage( /**Fixed Average Value*/ float fixedAverage){*
		this.fixedAverage = fixedAverage;
	*}

	/**
	 * Gets Fixed Average Value Property
	 */	
	float getFixedAverage() {*
		return this.fixedAverage;
	*}

	/**
	 * Sets Ignore Average Property
	 */	
	void setIgnoreAverage( /**Ignore Average*/ boolean ignoreAverage){*
		this.ignoreAverage = ignoreAverage;
	*}

	/**
	 * Gets Ignore Average Property
	 */	
	boolean isIgnoreAverage() {*
		return this.ignoreAverage;
	*}

	/**
	 * Sets Maximum Number Property
	 */	
	void setMaxNumber( /**Maximum Number*/ int maxNumber){*
		this.maxNumber = maxNumber;
	*}

	/**
	 * Gets Maximum Number Property
	 */	
	int getMaxNumber() {*
		return this.maxNumber;
	*}





	/**
	 * Gets Technical Property For Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Gets Technical Property For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Top X, Bottom X Or Both Property by String
	 */	
	void setTopBottomByString( /**Top X, Bottom X Or Both*/ String topBottom){*
		this.topBottom = topBottom;
	*}

	/**
	 * Gets Top X, Bottom X Or Both Property as String
	 */	
	String getTopBottomAsString() {*
		return this.topBottom;
	*}
	
	/**
	 * Sets Top X, Bottom X Or Both Property by Choice Option
	 */	
	void setTopBottom( /**Top X, Bottom X Or Both*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.topBottom = topBottom;
	*}
	
	/**
	 * Gets Top X, Bottom X Or Both Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.topBottom;
	*}

	/**
	 * Sets Use Pictures Property
	 */	
	void setUsePictures( /**Use Pictures*/ boolean usePictures){*
		this.usePictures = usePictures;
	*}

	/**
	 * Gets Use Pictures Property
	 */	
	boolean isUsePictures() {*
		return this.usePictures;
	*}

	/**
	 * Sets Value Decimal Places Property by String
	 */	
	void setValueDecimalPlacesByString( /**Value Decimal Places*/ String valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}

	/**
	 * Gets Value Decimal Places Property as String
	 */	
	String getValueDecimalPlacesAsString() {*
		return this.valueDecimalPlaces;
	*}
	
	/**
	 * Sets Value Decimal Places Property by Choice Option
	 */	
	void setValueDecimalPlaces( /**Value Decimal Places*/ org_scn_community_shared_DecimalPlacesEnumfield valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}
	
	/**
	 * Gets Value Decimal Places Property as Choice Option
	 */	
	org_scn_community_shared_DecimalPlacesEnumfield getValueDecimalPlaces() {*
		return this.valueDecimalPlaces;
	*}

	/**
	 * Sets Value Prefix Text Property
	 */	
	void setValuePrefix( /**Value Prefix Text*/ String valuePrefix){*
		this.valuePrefix = valuePrefix;
	*}

	/**
	 * Gets Value Prefix Text Property
	 */	
	String getValuePrefix() {*
		return this.valuePrefix;
	*}

	/**
	 * Sets Value Suffix Text Property
	 */	
	void setValueSuffix( /**Value Suffix Text*/ String valueSuffix){*
		this.valueSuffix = valueSuffix;
	*}

	/**
	 * Gets Value Suffix Text Property
	 */	
	String getValueSuffix() {*
		return this.valueSuffix;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for TopFlopChart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.TopFlopChart extends org.scn.community.shared.Component {

	/**
	 * Sets Add Counter Property
	 */	
	void setAddCounter( /**Add Counter*/ boolean addCounter){*
		this.addCounter = addCounter;
	*}

	/**
	 * Gets Add Counter Property
	 */	
	boolean isAddCounter() {*
		return this.addCounter;
	*}

	/**
	 * Sets Allow Any Interaction Property
	 */	
	void setAllowInteraction( /**Allow Any Interaction*/ boolean allowInteraction){*
		this.allowInteraction = allowInteraction;
	*}

	/**
	 * Gets Allow Any Interaction Property
	 */	
	boolean isAllowInteraction() {*
		return this.allowInteraction;
	*}

	/**
	 * Sets Prefix For Average Value Property
	 */	
	void setAveragePrefix( /**Prefix For Average Value*/ String averagePrefix){*
		this.averagePrefix = averagePrefix;
	*}

	/**
	 * Gets Prefix For Average Value Property
	 */	
	String getAveragePrefix() {*
		return this.averagePrefix;
	*}

	/**
	 * Sets Suffix For Average Value Property
	 */	
	void setAverageSuffix( /**Suffix For Average Value*/ String averageSuffix){*
		this.averageSuffix = averageSuffix;
	*}

	/**
	 * Gets Suffix For Average Value Property
	 */	
	String getAverageSuffix() {*
		return this.averageSuffix;
	*}

	/**
	 * Sets Place Empty Area After Average  Property
	 */	
	void setBreakOnAverage( /**Place Empty Area After Average */ boolean breakOnAverage){*
		this.breakOnAverage = breakOnAverage;
	*}

	/**
	 * Gets Place Empty Area After Average  Property
	 */	
	boolean isBreakOnAverage() {*
		return this.breakOnAverage;
	*}

	/**
	 * Sets Place An Empty Area After Index Property
	 */	
	void setBreakOnIndex( /**Place An Empty Area After Index*/ int breakOnIndex){*
		this.breakOnIndex = breakOnIndex;
	*}

	/**
	 * Gets Place An Empty Area After Index Property
	 */	
	int getBreakOnIndex() {*
		return this.breakOnIndex;
	*}



	/**
	 * Sets Delta Value Suffix Text Property
	 */	
	void setDeltaValueSuffix( /**Delta Value Suffix Text*/ String deltaValueSuffix){*
		this.deltaValueSuffix = deltaValueSuffix;
	*}

	/**
	 * Gets Delta Value Suffix Text Property
	 */	
	String getDeltaValueSuffix() {*
		return this.deltaValueSuffix;
	*}

	/**
	 * Sets Url For The Fallback Picture Property
	 */	
	void setFallbackPicture( /**Url For The Fallback Picture*/ String fallbackPicture){*
		this.fallbackPicture = fallbackPicture;
	*}

	/**
	 * Gets Url For The Fallback Picture Property
	 */	
	String getFallbackPicture() {*
		return this.fallbackPicture;
	*}

	/**
	 * Sets Fixed Average Value Property
	 */	
	void setFixedAverage( /**Fixed Average Value*/ int fixedAverage){*
		this.fixedAverage = fixedAverage;
	*}

	/**
	 * Gets Fixed Average Value Property
	 */	
	int getFixedAverage() {*
		return this.fixedAverage;
	*}

	/**
	 * Sets Ignore Average Property
	 */	
	void setIgnoreAverage( /**Ignore Average*/ boolean ignoreAverage){*
		this.ignoreAverage = ignoreAverage;
	*}

	/**
	 * Gets Ignore Average Property
	 */	
	boolean isIgnoreAverage() {*
		return this.ignoreAverage;
	*}

	/**
	 * Sets Maximum Number Property
	 */	
	void setMaxNumber( /**Maximum Number*/ int maxNumber){*
		this.maxNumber = maxNumber;
	*}

	/**
	 * Gets Maximum Number Property
	 */	
	int getMaxNumber() {*
		return this.maxNumber;
	*}

	/**
	 * Sets Maximal Value Area Size Property
	 */	
	void setMaxValueSize( /**Maximal Value Area Size*/ int maxValueSize){*
		this.maxValueSize = maxValueSize;
	*}

	/**
	 * Gets Maximal Value Area Size Property
	 */	
	int getMaxValueSize() {*
		return this.maxValueSize;
	*}





	/**
	 * Gets Technical Property For Pressed Key Property
	 */	
	String getPressedKey() {*
		return this.pressedKey;
	*}

	/**
	 * Gets Technical Property For Selected Key Property
	 */	
	String getSelectedKey() {*
		return this.selectedKey;
	*}

	/**
	 * Sets Show Average Information Property
	 */	
	void setShowAverage( /**Show Average Information*/ boolean showAverage){*
		this.showAverage = showAverage;
	*}

	/**
	 * Gets Show Average Information Property
	 */	
	boolean isShowAverage() {*
		return this.showAverage;
	*}

	/**
	 * Sets Show Delta Value In Item Property
	 */	
	void setShowDelta( /**Show Delta Value In Item*/ boolean showDelta){*
		this.showDelta = showDelta;
	*}

	/**
	 * Gets Show Delta Value In Item Property
	 */	
	boolean isShowDelta() {*
		return this.showDelta;
	*}

	/**
	 * Sets Top X, Bottom X Or Both Property by String
	 */	
	void setTopBottomByString( /**Top X, Bottom X Or Both*/ String topBottom){*
		this.topBottom = topBottom;
	*}

	/**
	 * Gets Top X, Bottom X Or Both Property as String
	 */	
	String getTopBottomAsString() {*
		return this.topBottom;
	*}
	
	/**
	 * Sets Top X, Bottom X Or Both Property by Choice Option
	 */	
	void setTopBottom( /**Top X, Bottom X Or Both*/ org_scn_community_shared_MemberSelectionEnumfield topBottom){*
		this.topBottom = topBottom;
	*}
	
	/**
	 * Gets Top X, Bottom X Or Both Property as Choice Option
	 */	
	org_scn_community_shared_MemberSelectionEnumfield getTopBottom() {*
		return this.topBottom;
	*}

	/**
	 * Sets Mark Background Property
	 */	
	void setUseBackground( /**Mark Background*/ boolean useBackground){*
		this.useBackground = useBackground;
	*}

	/**
	 * Gets Mark Background Property
	 */	
	boolean isUseBackground() {*
		return this.useBackground;
	*}

	/**
	 * Sets Use Delta As Value Property
	 */	
	void setUseDelta( /**Use Delta As Value*/ boolean useDelta){*
		this.useDelta = useDelta;
	*}

	/**
	 * Gets Use Delta As Value Property
	 */	
	boolean isUseDelta() {*
		return this.useDelta;
	*}

	/**
	 * Sets Use Pictures Property
	 */	
	void setUsePictures( /**Use Pictures*/ boolean usePictures){*
		this.usePictures = usePictures;
	*}

	/**
	 * Gets Use Pictures Property
	 */	
	boolean isUsePictures() {*
		return this.usePictures;
	*}

	/**
	 * Sets Value Decimal Places Property by String
	 */	
	void setValueDecimalPlacesByString( /**Value Decimal Places*/ String valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}

	/**
	 * Gets Value Decimal Places Property as String
	 */	
	String getValueDecimalPlacesAsString() {*
		return this.valueDecimalPlaces;
	*}
	
	/**
	 * Sets Value Decimal Places Property by Choice Option
	 */	
	void setValueDecimalPlaces( /**Value Decimal Places*/ org_scn_community_shared_DecimalPlacesEnumfield valueDecimalPlaces){*
		this.valueDecimalPlaces = valueDecimalPlaces;
	*}
	
	/**
	 * Gets Value Decimal Places Property as Choice Option
	 */	
	org_scn_community_shared_DecimalPlacesEnumfield getValueDecimalPlaces() {*
		return this.valueDecimalPlaces;
	*}

	/**
	 * Sets Value Prefix Text Property
	 */	
	void setValuePrefix( /**Value Prefix Text*/ String valuePrefix){*
		this.valuePrefix = valuePrefix;
	*}

	/**
	 * Gets Value Prefix Text Property
	 */	
	String getValuePrefix() {*
		return this.valuePrefix;
	*}

	/**
	 * Sets Text / Value Split Point Property
	 */	
	void setValueStart( /**Text / Value Split Point*/ int valueStart){*
		this.valueStart = valueStart;
	*}

	/**
	 * Gets Text / Value Split Point Property
	 */	
	int getValueStart() {*
		return this.valueStart;
	*}

	/**
	 * Sets Value Suffix Text Property
	 */	
	void setValueSuffix( /**Value Suffix Text*/ String valueSuffix){*
		this.valueSuffix = valueSuffix;
	*}

	/**
	 * Gets Value Suffix Text Property
	 */	
	String getValueSuffix() {*
		return this.valueSuffix;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for UI5Table
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.UI5Table extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Allow Reorder of Columns Property
	 */	
	void setAllowColumnReorder( /**Allow Reorder of Columns*/ boolean allowColumnReorder){*
		this.DAllowColumnReorder = allowColumnReorder;
	*}

	/**
	 * Gets Allow Reorder of Columns Property
	 */	
	boolean isAllowColumnReorder() {*
		return this.DAllowColumnReorder;
	*}

	/**
	 * Sets Allow Filter in Columns Property
	 */	
	void setAllowFilter( /**Allow Filter in Columns*/ boolean allowFilter){*
		this.DAllowFilter = allowFilter;
	*}

	/**
	 * Gets Allow Filter in Columns Property
	 */	
	boolean isAllowFilter() {*
		return this.DAllowFilter;
	*}

	/**
	 * Sets Allow Selection in the Table Property
	 */	
	void setAllowSelection( /**Allow Selection in the Table*/ boolean allowSelection){*
		this.DAllowSelection = allowSelection;
	*}

	/**
	 * Gets Allow Selection in the Table Property
	 */	
	boolean isAllowSelection() {*
		return this.DAllowSelection;
	*}

	/**
	 * Sets Allow Sort in Columns Property
	 */	
	void setAllowSort( /**Allow Sort in Columns*/ boolean allowSort){*
		this.DAllowSort = allowSort;
	*}

	/**
	 * Gets Allow Sort in Columns Property
	 */	
	boolean isAllowSort() {*
		return this.DAllowSort;
	*}

	/** Adds a root element containing key [String], width [String].

 	<example>
	You want to add 2 root elements
	<code>
	UI5TABLE.addColumnWidthEntry(key [String], width [String]);<br>
	UI5TABLE.addColumnWidthEntry(key [String], width [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addColumnWidthEntry (
			/**Column index (0-based)*/String key, 
			/**Width with unit (e.g. 200px | 30%)*/String width
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			width:width
			};

		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}

		var elementsJson = JSON.parse(this.DDataColWidths);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.DDataColWidths = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	UI5TABLE.removeColumnWidthEntry(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeColumnWidthEntry (
			String key
			) {*

		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}

		var elementsJson = JSON.parse(this.DDataColWidths);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.DDataColWidths = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	UI5TABLE.insertColumnWidthEntry(index [int], key [String], width [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertColumnWidthEntry (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Column index (0-based)*/String key, 
			/**Width with unit (e.g. 200px | 30%)*/String width
			) {*

		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}
		
		var elementsJson = JSON.parse(this.DDataColWidths);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			width:width
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.DDataColWidths = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given ColumnWidthEntry<br/>
	 */
	void updateColumnWidthEntry (
			/**Column index (0-based)*/String key, 
			/**Width with unit (e.g. 200px | 30%)*/String width
			) 
	{*
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			width:width
		};

		var elementsJson = JSON.parse(this.DDataColWidths);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.DDataColWidths = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getColumnWidthEntryAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}

		var elementsJson = JSON.parse(this.DDataColWidths);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets ColumnWidthEntrys As JSON String
	 */	
	String getColumnWidthEntrysAsJSON() {*
		var jsonObject = JSON.parse(this.DDataColWidths);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All ColumnWidthEntrys
	 */	
	String cleanAllColumnWidthEntrys() {*
		this.DDataColWidths = "[]";
	*}
	
	/**
	 * Sets the Width for ColumnWidthEntry keys<br/>
	 */
	void setColumnWidthEntryWidths (
			/**/ String keys,
			/**/ String separator,
	        /* Width */ String width
			) 
	{*
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DDataColWidths);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].width = width;
					break;
				}
			}
		}
		
		this.DDataColWidths = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Width for ColumnWidthEntry Key<br/>
	 */
	void setColumnWidthEntryWidth (
			/**/ String key,
			/**/ String width
			) 
	{*
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DDataColWidths);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].width = width;
				break;
			}
		}

		this.DDataColWidths = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Width for ColumnWidthEntry Key<br/>
	 */
	String getColumnWidthEntryWidth (
			/**/ String key
			) 
	{*
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DDataColWidths);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].width;
				break;
			}
		}
		
		return value;
	*}



	/**
	 * Sets Central Result Set with Data Property
	 */	
	void setDataProvisioner( /**Central Result Set with Data*/ String dataProvisioner){*
		this.DDataProvisioner = dataProvisioner;
	*}

	/**
	 * Gets Central Result Set with Data Property
	 */	
	String getDataProvisioner() {*
		return this.DDataProvisioner;
	*}

	/**
	 * Sets Empty Value For Data Cell Property
	 */	
	void setEmptyDataValue( /**Empty Value For Data Cell*/ String emptyDataValue){*
		this.DEmptyDataValue = emptyDataValue;
	*}

	/**
	 * Gets Empty Value For Data Cell Property
	 */	
	String getEmptyDataValue() {*
		return this.DEmptyDataValue;
	*}

	/**
	 * Sets Empty Value For Header Cell Property
	 */	
	void setEmptyHeaderValue( /**Empty Value For Header Cell*/ String emptyHeaderValue){*
		this.DEmptyHeaderValue = emptyHeaderValue;
	*}

	/**
	 * Gets Empty Value For Header Cell Property
	 */	
	String getEmptyHeaderValue() {*
		return this.DEmptyHeaderValue;
	*}

	/**
	 * Sets Fix Header Rows Property
	 */	
	void setFixedHeader( /**Fix Header Rows*/ boolean fixedHeader){*
		this.DFixedHeader = fixedHeader;
	*}

	/**
	 * Gets Fix Header Rows Property
	 */	
	boolean isFixedHeader() {*
		return this.DFixedHeader;
	*}

	/** Adds an element containing parentKey [String], key [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	UI5TABLE.addMembers(parentKey [String], key [String]);<br>
	UI5TABLE.addMembers(parentKey [String], key [String]);
	</code>
	</example>
	 */
	void addMembers (
			/**Parent Key*/String parentKey, 
			/**Content*/String key
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key 
			};
	
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			this.DFormattingContentCondition = "[]";
		}
		
		var elementsJson = JSON.parse(this.DFormattingContentCondition);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/** Adds a root element containing key [String], description [String], condition [String], columnHeaderId [String], exclude [boolean], simpleFormat [String].

 	<example>
	You want to add 2 root elements
	<code>
	UI5TABLE.addRule(key [String], description [String], condition [String], columnHeaderId [String], exclude [boolean], simpleFormat [String]);<br>
	UI5TABLE.addRule(key [String], description [String], condition [String], columnHeaderId [String], exclude [boolean], simpleFormat [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addRule (
			/**Unique Rule Key*/String key, 
			/**Optional Description*/String description, 
			/**Condition*/String condition, 
			/**Column Header Id*/String columnHeaderId, 
			/**Exclude*/boolean exclude, 
			/**Simple Format Name*/String simpleFormat
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			description:description, 
			condition:condition, 
			columnHeaderId:columnHeaderId, 
			exclude:exclude, 
			simpleFormat:simpleFormat 
			};
	
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			this.DFormattingContentCondition = "[]";
		}
		
		var elementsJson = JSON.parse(this.DFormattingContentCondition);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	UI5TABLE.removeMembers(String key);<br>
	</code>
	</example>
	 */
	void removeMembers (
			String key
			) {*		
		
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			this.DFormattingContentCondition = "[]";
		}
		
		var elementsJson = JSON.parse(this.DFormattingContentCondition);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	UI5TABLE.removeRule(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeRule (
			String key
			) {*		
		
		this.removeMembers(key);
	*}

	/**
	 * Gets Rules As JSON String
	 */	
	String getRulesAsJSON() {*
		var jsonObject = JSON.parse(this.DFormattingContentCondition);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Cleans All Rules
	 */	
	String cleanAllRules() {*
		this.DFormattingContentCondition = "[]";
	*}
	/**
	 * Sets the Description for Rule keys<br/>
	 */
	void setRuleDescriptions (
			/**/ String keys,
			/**/ String separator,
	        /* Description */ String description
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].description = description;
					break;
				}
			}
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Description for Rule Key<br/>
	 */
	void setRuleDescription (
			/**/ String key,
			/**/ String description
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].description = description;
				break;
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Description for Rule Key<br/>
	 */
	String getRuleDescription (
			/**/ String key
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].description;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Condition for Rule keys<br/>
	 */
	void setRuleConditions (
			/**/ String keys,
			/**/ String separator,
	        /* Condition */ String condition
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].condition = condition;
					break;
				}
			}
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Condition for Rule Key<br/>
	 */
	void setRuleCondition (
			/**/ String key,
			/**/ String condition
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].condition = condition;
				break;
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Condition for Rule Key<br/>
	 */
	String getRuleCondition (
			/**/ String key
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].condition;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the ColumnHeaderId for Rule keys<br/>
	 */
	void setRuleColumnHeaderIds (
			/**/ String keys,
			/**/ String separator,
	        /* ColumnHeaderId */ String columnHeaderId
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].columnHeaderId = columnHeaderId;
					break;
				}
			}
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the ColumnHeaderId for Rule Key<br/>
	 */
	void setRuleColumnHeaderId (
			/**/ String key,
			/**/ String columnHeaderId
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].columnHeaderId = columnHeaderId;
				break;
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of ColumnHeaderId for Rule Key<br/>
	 */
	String getRuleColumnHeaderId (
			/**/ String key
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].columnHeaderId;
				break;
			}
		}
		
		return value;
	*}
	/**
	 * Sets the Exclude for Rule keys<br/>
	 */
	void setRuleExcludes (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].exclude = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].exclude = true;
					break;
				}
			}
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Exclude for Rule Key<br/>
	 */
	void setRuleExclude (
			/**/ String key,
			/**/ boolean exclude
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].exclude = exclude;
				break;
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all Exclude of Rule keys<br/>
	 */
	void cleanAllRuleExcludes (
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].exclude = false;
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of Exclude for Rule Key<br/>
	 */
	String getRuleExclude (
			/**/ String key
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		var value = undefined;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].exclude;
				break;
			}
		}
		
		return value;
	*}

	/**
	 * Returns the Exclude keys<br/>
	 */
	org.scn.community.shared.KeyArray getRuleExcludeKeysArray (
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.DFormattingContentCondition);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].exclude == true) {
				newElementsJson.push({"key": elementsJson[i].key});
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the SimpleFormat for Rule keys<br/>
	 */
	void setRuleSimpleFormats (
			/**/ String keys,
			/**/ String separator,
	        /* SimpleFormat */ String simpleFormat
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].simpleFormat = simpleFormat;
					break;
				}
			}
		}
		
		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the SimpleFormat for Rule Key<br/>
	 */
	void setRuleSimpleFormat (
			/**/ String key,
			/**/ String simpleFormat
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].simpleFormat = simpleFormat;
				break;
			}
		}

		this.DFormattingContentCondition = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Returns value of SimpleFormat for Rule Key<br/>
	 */
	String getRuleSimpleFormat (
			/**/ String key
			) 
	{*
		if (this.DFormattingContentCondition === undefined || this.DFormattingContentCondition === "" || this.DFormattingContentCondition === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.DFormattingContentCondition);

		var value = "";
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				value = elementsJson[i].simpleFormat;
				break;
			}
		}
		
		return value;
	*}


	/**
	 * Sets Formatting Operator Property by String
	 */	
	void setFormattingOperatorByString( /**Formatting Operator*/ String formattingOperator){*
		this.DFormattingOperator = formattingOperator;
	*}

	/**
	 * Gets Formatting Operator Property as String
	 */	
	String getFormattingOperatorAsString() {*
		return this.DFormattingOperator;
	*}
	
	/**
	 * Sets Formatting Operator Property by Choice Option
	 */	
	void setFormattingOperator( /**Formatting Operator*/ org_scn_community_shared_FormattingOperatorEnumfield formattingOperator){*
		this.DFormattingOperator = formattingOperator;
	*}
	
	/**
	 * Gets Formatting Operator Property as Choice Option
	 */	
	org_scn_community_shared_FormattingOperatorEnumfield getFormattingOperator() {*
		return this.DFormattingOperator;
	*}

	/**
	 * Sets Rules for Number Values Property
	 */	
	void setFormattingValueCondition( /**Rules for Number Values*/ String formattingValueCondition){*
		this.DFormattingValueCondition = formattingValueCondition;
	*}

	/**
	 * Gets Rules for Number Values Property
	 */	
	String getFormattingValueCondition() {*
		return this.DFormattingValueCondition;
	*}

	/**
	 * Sets Header Column Width in px Property
	 */	
	void setHeaderColWidth( /**Header Column Width in px*/ int headerColWidth){*
		this.DHeaderColWidth = headerColWidth;
	*}

	/**
	 * Gets Header Column Width in px Property
	 */	
	int getHeaderColWidth() {*
		return this.DHeaderColWidth;
	*}

	/**
	 * Sets Fixed Column Index (-1 means Row Dimensions) Property
	 */	
	void setHeaderColumnFixed( /**Fixed Column Index (-1 means Row Dimensions)*/ int headerColumnFixed){*
		this.DHeaderColumnFixed = headerColumnFixed;
	*}

	/**
	 * Gets Fixed Column Index (-1 means Row Dimensions) Property
	 */	
	int getHeaderColumnFixed() {*
		return this.DHeaderColumnFixed;
	*}

	/**
	 * Sets Ignore Results Property
	 */	
	void setIgnoreResults( /**Ignore Results*/ boolean ignoreResults){*
		this.DIgnoreResults = ignoreResults;
	*}

	/**
	 * Gets Ignore Results Property
	 */	
	boolean isIgnoreResults() {*
		return this.DIgnoreResults;
	*}

	/**
	 * Sets Show Only Header Columns Property
	 */	
	void setOnlyHeaderColumns( /**Show Only Header Columns*/ boolean onlyHeaderColumns){*
		this.DOnlyHeaderColumns = onlyHeaderColumns;
	*}

	/**
	 * Gets Show Only Header Columns Property
	 */	
	boolean isOnlyHeaderColumns() {*
		return this.DOnlyHeaderColumns;
	*}

	/**
	 * Sets Row Height in px Property
	 */	
	void setRowHeight( /**Row Height in px*/ int rowHeight){*
		this.DRowHeight = rowHeight;
	*}

	/**
	 * Gets Row Height in px Property
	 */	
	int getRowHeight() {*
		return this.DRowHeight;
	*}



	/**
	 * Sets Selection Mode Property by String
	 */	
	void setSelectionModeByString( /**Selection Mode*/ String selectionMode){*
		this.DSelectionMode = selectionMode;
	*}

	/**
	 * Gets Selection Mode Property as String
	 */	
	String getSelectionModeAsString() {*
		return this.DSelectionMode;
	*}
	
	/**
	 * Sets Selection Mode Property by Choice Option
	 */	
	void setSelectionMode( /**Selection Mode*/ org_scn_community_shared_SelectionModeEnumfield selectionMode){*
		this.DSelectionMode = selectionMode;
	*}
	
	/**
	 * Gets Selection Mode Property as Choice Option
	 */	
	org_scn_community_shared_SelectionModeEnumfield getSelectionMode() {*
		return this.DSelectionMode;
	*}

	/**
	 * Sets Show Keys instead of Texts Property
	 */	
	void setShowKeys( /**Show Keys instead of Texts*/ boolean showKeys){*
		this.DShowKeys = showKeys;
	*}

	/**
	 * Gets Show Keys instead of Texts Property
	 */	
	boolean isShowKeys() {*
		return this.DShowKeys;
	*}

	/**
	 * Sets Sort Mode Property by String
	 */	
	void setSortModeByString( /**Sort Mode*/ String sortMode){*
		this.DSortMode = sortMode;
	*}

	/**
	 * Gets Sort Mode Property as String
	 */	
	String getSortModeAsString() {*
		return this.DSortMode;
	*}
	
	/**
	 * Sets Sort Mode Property by Choice Option
	 */	
	void setSortMode( /**Sort Mode*/ org_scn_community_shared_Enumfield sortMode){*
		this.DSortMode = sortMode;
	*}
	
	/**
	 * Gets Sort Mode Property as Choice Option
	 */	
	org_scn_community_shared_Enumfield getSortMode() {*
		return this.DSortMode;
	*}

	/**
	 * Sets Visible Row Count Property
	 */	
	void setVisibleRowCount( /**Visible Row Count*/ int visibleRowCount){*
		this.DVisibleRowCount = visibleRowCount;
	*}

	/**
	 * Gets Visible Row Count Property
	 */	
	int getVisibleRowCount() {*
		return this.DVisibleRowCount;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Gets Selection As JSON String
	 */	
	String getSelectionAsJSON() {*
		var jsonObject = JSON.parse(this.DSelection);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Gets Selection As JSON String
	 */	
	JSON getSelectionAsJSONObject() {*
		var jsonObject = JSON.parse(this.DSelection);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Selected Row Index (0 - based)
	 */
	int getSelectedRow() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.row;
	*}
	
	/**
	 * Selected Column Index (0 - based)
	 */
	int getSelectedColumn() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.column;
	*}

	/**
	 * Selected Visual Row Index (0 - based)
	 */
	int getSelectedVisualRow() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.visualRow;
	*}
	
	/**
	 * Selected Visual Column Index (0 - based)
	 */
	int getSelectedVisualColumn() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.visualColumn;
	*}

	/**
	 * Selected Value Content
	 */
	int getSelectedValue() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.value;
	*}
	
	/**
	 * Selection Space (Header, Data)
	 */
	String getSelectionSpace() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.value;
	*}

	/**
	 * Return dimensions and corresponding members for the selection as array
	 */
	org.scn.community.shared.DimensionMemberArray getSelectionDimensionMembers() {*
		var tempA = [];
		if(this.DSelection == undefined || this.DSelection == "") {
			return tempA;
		}

		var jsonObject = JSON.parse(this.DSelection);
		
		for(var i=0;i<jsonObject.rowDimensions.length;i++){
			var itemDef = { 
				"dimension": jsonObject.rowDimensions[i].key, 
				"member": jsonObject.rowKeys[i]
			};
			
			tempA.push(itemDef);
		}
		
		if(jsonObject.columnDimensions) {
			for(var i=0;i<jsonObject.columnDimensions.length;i++){
				var itemDef = { 
					"dimension": jsonObject.columnDimensions[i].key, 
					"member": jsonObject.columnKeys[i]
				};
				
				tempA.push(itemDef);
			}
		}
		
		return tempA;
	*}

	/**
	 * Values of the Row
	 */
	StringArray getSelectionRowValues() {*
		var jsonObject = JSON.parse(this.DSelection);
		
	
		var tempA = [];
		for(var i=0;i<jsonObject.rowValues.length;i++){
			var itemDef = jsonObject.rowValues[i];
			
			tempA.push(itemDef);
		}

		return tempA;
	*}
	
	/**
	 * This method is not functional any more, keeping only to avoid compilation issues! #153
	 */	
	void setNavigationModeByString( /**Navigation Mode*/ String navigationMode){*
		
	*}

	/**
	 * This method is not functional any more, keeping only to avoid compilation issues! #153
	 */	
	String getNavigationModeAsString() {*
		return "Scrollbar";
	*}

	/**
	 * This method is not functional any more, keeping only to avoid compilation issues! #153
	 */	
	void setNavigationMode( /**Navigation Mode*/ org_scn_community_shared_NavigationModeEnumfield navigationMode){*
		
	*}
	
	/**
	 * This method is not functional any more, keeping only to avoid compilation issues! #153
	 */	
	org_scn_community_shared_NavigationModeEnumfield getNavigationMode() {*
		return "Scrollbar";
	*}
}

/**
 * Generated ZTL Class for AreaMicroChart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.AreaMicroChart extends org.scn.community.shared.ui5.MicroAreaChart {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for BulletMicroChart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.BulletMicroChart extends org.scn.community.shared.ui5.BulletChart {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

/**
 * Generated ZTL Class for HarveyBallMicroChart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.HarveyBallMicroChart extends org.scn.community.shared.ui5.HarveyBallMicroChart {


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/* ZTL END */